<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ThreadPool线程池 | xuchaoのblog</title><meta name="keywords" content="juc"><meta name="author" content="xuchao"><meta name="copyright" content="xuchao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Future使用姿势注意12345678910111213141516171819public static void main(String args[]) throws Exception &amp;#123;       &#x2F;&#x2F; 使用       ExecutorService executor &#x3D; Executors.newCachedThreadPool();       Callable c &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadPool线程池">
<meta property="og:url" content="https://xuchao6969.github.io/2022/05/03/ThreadPool/index.html">
<meta property="og:site_name" content="xuchaoのblog">
<meta property="og:description" content="Future使用姿势注意12345678910111213141516171819public static void main(String args[]) throws Exception &amp;#123;       &#x2F;&#x2F; 使用       ExecutorService executor &#x3D; Executors.newCachedThreadPool();       Callable c &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xuchao6969.github.io/img/leiwujie2.jpg">
<meta property="article:published_time" content="2022-05-03T01:20:51.000Z">
<meta property="article:modified_time" content="2023-04-08T11:36:54.203Z">
<meta property="article:author" content="xuchao">
<meta property="article:tag" content="juc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xuchao6969.github.io/img/leiwujie2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xuchao6969.github.io/2022/05/03/ThreadPool/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50000,"languages":{"author":"作者: xuchao","link":"链接: ","source":"来源: xuchaoのblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ThreadPool线程池',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-08 19:36:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/leiwujie1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/leiwujie2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">xuchaoのblog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ThreadPool线程池</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-03T01:20:51.000Z" title="发表于 2022-05-03 09:20:51">2022-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-08T11:36:54.203Z" title="更新于 2023-04-08 19:36:54">2023-04-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Future使用姿势注意"><a href="#Future使用姿势注意" class="headerlink" title="Future使用姿势注意"></a>Future使用姿势注意</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) throws Exception &#123;</span><br><span class="line">       // 使用</span><br><span class="line">       ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">       Callable c = new Callable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public Object call() throws Exception &#123;</span><br><span class="line">               Thread.sleep(10000);</span><br><span class="line">               return 100;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">	//注意这里实际调用的是AbstractExecutorService#submit(Callable&lt;T&gt; task)方法</span><br><span class="line">	//构造了一个ftask，然后开启一个线程A去执行callable的任务，返回ftask</span><br><span class="line">	//当线程A没有执行完callable的任务就调用了get方法去获取结果当前线程就会被阻塞或阻塞一定时间，超时还没拿到就会抛超时异常</span><br><span class="line">       Future&lt;Integer&gt; result = executor.submit(c);</span><br><span class="line">       // 注意调用get方法会阻塞当前线程，直到得到结果。</span><br><span class="line">       // 所以实际编码中建议使用可以设置超时时间的重载get方法。</span><br><span class="line">	// 不过也不建议使用 因为有超时时间的也会阻塞当前线程一定的超时时间，超时过后还没拿到结果会抛出超时异常</span><br><span class="line">       System.out.println(result.get()); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>Future接口只有几个比较简单的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract interface Future&lt;V&gt; &#123;</span><br><span class="line">    public abstract boolean cancel(boolean paramBoolean);</span><br><span class="line">    public abstract boolean isCancelled();</span><br><span class="line">    public abstract boolean isDone();</span><br><span class="line">    public abstract V get() throws InterruptedException, ExecutionException;</span><br><span class="line">    public abstract V get(long paramLong, TimeUnit paramTimeUnit)</span><br><span class="line">            throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cancel方法是试图取消一个线程的执行。<br>注意是试图取消，并不一定能取消成功。因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。<br>boolean类型的返回值是”是否取消成功”的意思。参数paramBoolean表示是否采用中断的方式取消线程执行。</p>
<p>所以有时候，为了让任务有能够取消的功能，就使用Callable来代替Runnable。如果为了可取消性而使用 Future但又不提供可用的结果，则可以声明 Future&lt;?&gt;形式类型、并返回 null作为底层任务的结果。</p>
<h2 id="FutureTask使用姿势注意"><a href="#FutureTask使用姿势注意" class="headerlink" title="FutureTask使用姿势注意"></a>FutureTask使用姿势注意</h2><p>FutureTask是实现的RunnableFuture接口的，而RunnableFuture接口同时继承了Runnable接口和Future接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Sets this Future to the result of its computation</span><br><span class="line">     * unless it has been cancelled.</span><br><span class="line">     */</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那FutureTask类有什么用？为什么要有一个FutureTask类？前面说到了Future只是一个接口，而它里面的cancel，get，isDone等方法要自己实现起来都是非常复杂的。所以JDK提供了一个FutureTask类来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) throws Exception &#123;</span><br><span class="line">	// 使用</span><br><span class="line">	ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">	Callable c = new Callable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object call() throws Exception &#123;</span><br><span class="line">                Thread.sleep(10000);</span><br><span class="line">                return 100;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">	FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(c);</span><br><span class="line">	//注意这里实际调用的是AbstractExecutorService#submit(Runnable task) 方法	//该方法返回了一个构造ftask，ftask构造方法传递的默认值是null，源码最底层构造了RunnableAdapter(原来的Runable转换成了Callable，有</span><br><span class="line">	//一个call方法且该call方法返回了result 也就是null)。AbstractExecutorService#submit(Runnabletask)执行execute(ftask)把该任</span><br><span class="line">	//务纳入线程池管理(可能有核心线程执行、非核心线程执行，入队后等待线程去执行)等</span><br><span class="line">	//待执行，如果有线程可以执行该任务会走Thread#run(),该方法中判断target对象(也就是线程池中的Worker对象)是否为空，</span><br><span class="line">	//不为空的话执行worker对象的run方法即runWorker(this)，在runWorker方法中会调用task.run()方法，</span><br><span class="line">	//也就是FutureTask的run方法,FutureTask的run方法中进而会继续调用Callable c的call方法也就是之前构造的RunnableAdapter的call方法，拿到返回值</span><br><span class="line">	//这个返回值是RunnableAdapter构造时候设置的result也就是null，回到FutureTask的run方法继续执行，会在最后调用FutureTask的set方法赋值set(null)</span><br><span class="line">	//具体细节是把outcome设为null</span><br><span class="line">	//这样使用future的get()方法，其实是FutureTask的get方法，判断任务执行完了没有没有的话就等待执行完成，执行完成后会设置outcome，</span><br><span class="line">	//最后调用report(int s)方法，获取到的outcome就是null</span><br><span class="line">	Future f = executor.submit(futureTask);</span><br><span class="line">	System.out.println(f.get());//null</span><br><span class="line">	System.out.println(futureTask.get());//100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上与Future有一点小的区别。首先，调用submit方法得到的Future对象获取值的时候是null，因为这里实际上是调用的submit(Runnable task)方法，而上面的Future使用注意Demo，调用的是submit(Callable<T> task)方法，有返回值。</p>
<p>然后，这里是使用FutureTask直接取get取值，而上面的Demo是通过submit方法返回的Future去取值。</p>
<p>在很多高并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能够在高并发环境下确保任务只执行一次。这块有兴趣的同学可以参看FutureTask源码。</p>
<p>另外从上边也可以看到线程池执行任务最终都是执行的execute方法！！！</p>
<h2 id="ThreadPooolExecutor-execute方法赏析"><a href="#ThreadPooolExecutor-execute方法赏析" class="headerlink" title="ThreadPooolExecutor#execute方法赏析"></a>ThreadPooolExecutor#execute方法赏析</h2><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
<p>线程池创建后处于RUNNING状态。<br>调用shutdown()方法后处于SHUTDOWN状态，线程池不能接受新的任务，清除一些空闲worker,不会等待阻塞队列的任务完成。<br>调用shutdownNow()方法后处于STOP状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，poolsize&#x3D;0,阻塞队列的size也为0。<br>当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。接着会执行terminated()函数。<br>线程池处在TIDYING状态时，执行完terminated()方法之后，就会由 TIDYING -&gt; TERMINATED， 线程池被设置为TERMINATED状态。</p>
<h3 id="构造方法-参数最全的"><a href="#构造方法-参数最全的" class="headerlink" title="构造方法(参数最全的)"></a>构造方法(参数最全的)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">						  int maximumPoolSize,</span><br><span class="line">						  long keepAliveTime,</span><br><span class="line">						  TimeUnit unit,</span><br><span class="line">						  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">						  ThreadFactory threadFactory,</span><br><span class="line">						  RejectedExecutionHandler handler) &#123;</span><br><span class="line">      ···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>int corePoolSize：该线程池中核心线程数最大值<br>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干，而非核心线程如果长时间的闲置，就会被销毁（临时工）。官方文档说如果线程池中的核心线程数少于设定的核心线程数，只有新任务到来时才会创建核心线程来处理任务，即使有别的核心线程空闲也不会使用别的空闲核心线程执行任务</p>
</li>
<li><p>int maximumPoolSize：该线程池中线程总数最大值(也就是 核心线程数量 + 非核心线程数量)<br>方文档说：如果线程池中的线程数量超过了核心线程数，但没有超过线程池的线程总数最大值，任务队列也满了，，，就创建非核心线程来执行任务</p>
</li>
<li><p>long keepAliveTime：非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。这么做的好处就是降低资源的消耗</p>
</li>
<li><p>TimeUnit unit：keepAliveTime的单位</p>
</li>
<li><p>ThreadFactory threadFactory：创建线程的工厂<br>用于批量创建线程，可以在创建线程时设置一些参数，如线程组、是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。注意官方说：如果线程工厂创建线程方法newThread方法返回一个null时，executor会继续，但不会处理任何任务。线程池中的工作线程应该拥有 “modifyThread” 权限。如果工作线程或其他使用线程池的线程没有此权限，则可能会导致服务降级。具体表现为配置更改可能无法及时生效，关闭线程池时可能会出现线程未正常终止的情况。怎么理解”modifyThread”权限?这么理解Java线程池在执行任务时需要对线程进行调度和管理，如创建、销毁、中断等操作，而这些操作需要修改线程的状态和属性，如果没有 “modifyThread” 权限，则线程无法被正常调度和管理，导致线程池无法正常工作。<br>因此，在使用Java线程池时，我们需要确保线程池中的工作线程或其他线程都具有 “modifyThread” 权限，以确保线程池的正常工作。同时，我们还需要合理配置线程池参数，如线程池大小、任务队列容量等，以避免出现线程过多或任务过多的情况，导致线程池的性能下降或甚至崩溃。</p>
</li>
<li><p>BlockingQueue<Runnable> workQueue：阻塞队列，维护着提交过来的等待执行的任务对象<br>如果线程池中的线程数少于核心线程数，线程池会创建一个核心线程来处理提交过来的任务，而不是把任务入队；如果池中的线程数大于核心线程数，任务提交过来时会被放到阻塞队列中，而不是创建新线程；如果请求任务无法排队(队列满了)，则会创建一个新线程，除非该线程超过 maxumPoolSize，在这种情况下，任务将被拒绝(队列满了，如果线程池中的线程小于最大线程数，则会创建线程执行任务，如果线程数等于或超过了最大线程数，则会拒绝任务)。<br>下面介绍几种常用的队列：</p>
</li>
</ul>
<ul>
<li>SynchronousQueue 同步队列，内部容量为0，每个put操作必须等待一个take操作，每个take操作必须等待一个put操作。它将任务传递给线程，而不持有它们。在这里，如果没有立即可用的线程来运行任务，那么对任务进行排队的尝试将失败，因此将构造一个新线程。向队列提交任务平均速度快于它们的处理速度时，线程可能会无限增长，容易oom。</li>
<li>LinkedBlockingQueue<br>链式阻塞队列，底层数据结构是链表，默认大小是Integer.MAX_VALUE，也可以指定大小。<br>使用无限队列（例如，没有预定义容量的 LinkedBlockingQueue）将导致当所有 corePoolSize 线程都繁忙时，新任务在队列中等待。因此，不会创建超过corePoolSize的线程。（因此，最大池大小的值没有任何影响。当每个任务完全独立于其他任务时，这可能是合适的，因此任务不能影响彼此的执行;例如，在网页服务器中。虽然这种排队方式在平滑请求的暂时突发方面很有用，但它承认当任务到达的速度快于处理速度时，工作队列无限增长的可能性。容易oom。</li>
<li>ArrayBlockingQueue<br>数组阻塞队列，底层数据结构是数组，需要指定队列的大小。有界队列（例如，ArrayBlockingQueue）在与有固定线程数的连接池一起使用时有助于防止资源耗尽，但可能更难调整和控制。队列大小和线程池线程数量大小可以相互权衡：使用大队列和小池可以最大程度地减少 CPU 使用率、操作系统资源和上下文切换开销，但可能会导致人为的低吞吐量。如果任务经常阻塞（例如，如果任务受 IO 限制），则系统可能为线程调度更多的线程执行时间(比您允许的还要多)。使用小型队列通常需要较大的线程池，这使 CPU 更加繁忙，但可能会遇到不可接受的调度开销，这也会降低吞吐量。</li>
<li>DelayQueue<br>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</li>
</ul>
<ul>
<li>RejectedExecutionHandler handler拒绝策略<br>当线程池已经关闭时，或者当线程池的最大线程和工作队列容量使用有限边界并饱和时，在方法 execute（Runnable） 中提交的新任务将被拒绝。在任一情况下，execute 方法都会调用其 RejectedExecutionHandler的RejectedExecution.rejectedExecution（Runnable， ThreadPoolExecutor）方法。线程池提供了四种拒绝策略：<br>ThreadPoolExecutor.AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。</li>
</ul>
<p>ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。</p>
<p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</p>
<p>ThreadPoolExecutor.CallerRunsPolicy：由调用线程本身(调用execute方法的线程)处理该任务，这提供了一个简单的反馈控制机制，可以减慢新任务的提交速度。</p>
<p>官网提示我们可以定义和使用其他类型的 RejectedExecutionHandler 类。这样做需要格外小心，尤其是当策略设计为仅在特定容量或队列策略下工作时。</p>
<h3 id="线程池执行任务入口"><a href="#线程池执行任务入口" class="headerlink" title="线程池执行任务入口"></a>线程池执行任务入口</h3><p>ThreadPoolExecutor#execute方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">        if (command == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        /*</span><br><span class="line">         * Proceed in 3 steps:</span><br><span class="line">         *</span><br><span class="line">         * 1. 如果线程池中的核心线程数没有到达预设数量，直接创建worker使核心线程尽快到达预设数量，如果返回false说明不应该添加线程</span><br><span class="line">         *</span><br><span class="line">         * 2. 如果一个任务可以成功排队，那么我们仍然需要再次检查是否应该添加一个线程(因为上次检查后已有线程死亡)，或者自从进入这</span><br><span class="line">		 *    个方法后线程池被关闭了。因此，我们重新检查状态，如果有必要，回滚正在排队的线程，如果没有，就开始一个新线程。</span><br><span class="line">         *</span><br><span class="line">         * 3. 如果不能将任务排队，则尝试添加一个新线程。如果它失败了，我们知道我们已经关闭或饱和，因此拒绝任务。</span><br><span class="line">         */</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">		//workCountOf获取线程的状态和工作线程的数量。ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个AtomicInteger类型的变量。</span><br><span class="line">		//线程池状态就是通过AtomicInteger类型的成员变量ctl来获取的。获取的ctl值传入runStateOf方法，与~CAPACITY位与运算(CAPACITY是低29位全1的int变量)。</span><br><span class="line">        //~CAPACITY在这里相当于掩码，用来获取ctl的高3位，表示线程池状态；而另外的低29位用于表示工作线程数</span><br><span class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">			// 走到这里说明当前线程池中的线程数少于核心线程数，创建核心线程执行任务</span><br><span class="line">			// 注意这里是true标记要创建的工作线程是核心线程，创建核心线程绑定任务command</span><br><span class="line">            if (addWorker(command, true))</span><br><span class="line">                return;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">		// 走到这里说明池内线程数目不小于corePoolSize，尝试入队</span><br><span class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck = ctl.get();</span><br><span class="line">			// 如果线程池不是运行状态，就移除这个任务，执行拒绝策略</span><br><span class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">			// 线程池是运行状态，工作线程数量是0，就创建非核心线程(注意这里并没有绑定任务command，任务已经入</span><br><span class="line">			//队了，创建空闲非核心线程让他去队列中取任务执行)</span><br><span class="line">            else if (workerCountOf(recheck) == 0)</span><br><span class="line">                addWorker(null, false);</span><br><span class="line">        &#125;</span><br><span class="line">		// 走到这里说明任务入队失败了，当前线程池的线程数超过了核心线程数，队列也满了，如果池内线程数没超过最大线程数执行addWorker方法</span><br><span class="line">		// 注意这里是false，创建非核心线程绑定任务command，如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span><br><span class="line">        else if (!addWorker(command, false))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h4><p>根据当前池状态和给定边界（核心或最大）检查是否可以添加新工作线程。如果是这样，则会相应地调整工作线程计数，如果可能，将创建并启动一个新工作线程，将 firstTask 作为其第一个任务运行。如果池已停止或符合关闭条件，则此方法返回 false。如果线程工厂在询问时无法创建线程，它也返回 false。如果线程创建失败，要么是由于线程工厂返回 null，要么是由于异常（通常是 Thread.start（） 中的 OutOfMemoryError），就会干净地回滚。<br>参数firstTask 就是线程池execute方法提交过来的任务，当核心线程数少于设定时，就会创建一个核心线程绑定提交过来的任务；或者队列满了但线程池的线程还未超过最大值，就会创建一个非核心线程绑定提交过来的任务，这也是进入addWork方法的两条路径。<br>参数core就是用来设定绑定任务的线程是核心的还是非核心线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"> private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">     retry://这是个循环标记 可以一次性continue或者break整个多层循环 学到了 用到开发中会不会被打？？？</span><br><span class="line">     for (;;) &#123;</span><br><span class="line">         int c = ctl.get();</span><br><span class="line">         int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">         // 检查线程池状态是否关闭了或者已经没有要处理的任务了，如果是就返回</span><br><span class="line">         if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">             ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == null &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">             return false;</span><br><span class="line">//</span><br><span class="line">         for (;;) &#123;</span><br><span class="line">	// 获取池中的线程数量</span><br><span class="line">             int wc = workerCountOf(c);</span><br><span class="line">	// core为true 检查池中的线程数是否&gt;=核心线程数，如果是 就返回false回到execute方法进行入队</span><br><span class="line">	// core为false检查池中的线程数是否&gt;=最大线程数，如果是 就返回false回到execute方法进行拒绝策略执行</span><br><span class="line">             if (wc &gt;= CAPACITY ||</span><br><span class="line">                 wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                 return false;</span><br><span class="line">	// 调用Unsafe类的原子性的改变线程池的状态</span><br><span class="line">             if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                 break retry;</span><br><span class="line">	// 再次检查线程池的状态</span><br><span class="line">             c = ctl.get();  // Re-read ctl</span><br><span class="line">	// 线程池状态不一致说明线程池已经又被别的任务提交改变了状态就重试</span><br><span class="line">             if (runStateOf(c) != rs)</span><br><span class="line">                 continue retry;</span><br><span class="line">             // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     boolean workerStarted = false;</span><br><span class="line">     boolean workerAdded = false;</span><br><span class="line">     Worker w = null;</span><br><span class="line">     try &#123;</span><br><span class="line">// 创建一个worker工作线程绑定好任务</span><br><span class="line">         w = new Worker(firstTask);</span><br><span class="line">         final Thread t = w.thread;</span><br><span class="line">         if (t != null) &#123;</span><br><span class="line">	//获取线程池的锁</span><br><span class="line">             final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">             mainLock.lock();</span><br><span class="line">             try &#123;</span><br><span class="line">                 // 检查线程池的状态 防止别的任务提交或者别的线程调用了shutdown方法对线程池状态的修改</span><br><span class="line">                 int rs = runStateOf(ctl.get());</span><br><span class="line">                 // 检查线程池处于活动状态或者 线程池停止了且提交的任务是null</span><br><span class="line">                 if (rs &lt; SHUTDOWN ||</span><br><span class="line">                     (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">			// 检查任务绑定的线程是否活着(已经started)了，如果是就抛异常</span><br><span class="line">                     if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                         throw new IllegalThreadStateException();</span><br><span class="line">			//添加工作线程到HashSet中</span><br><span class="line">                     workers.add(w);</span><br><span class="line">                     int s = workers.size();</span><br><span class="line">                     if (s &gt; largestPoolSize)</span><br><span class="line">                         largestPoolSize = s;</span><br><span class="line">			// 标记已经创建工作者线程</span><br><span class="line">                     workerAdded = true;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; finally &#123;</span><br><span class="line">                 mainLock.unlock();</span><br><span class="line">             &#125;</span><br><span class="line">	// 创建工作者线程后  </span><br><span class="line">             if (workerAdded) &#123;</span><br><span class="line">	    // 启动线程执行任务！！！！！！！！！！！！！！！！！！</span><br><span class="line">                 t.start();</span><br><span class="line">		// 标记任务开始执行</span><br><span class="line">                 workerStarted = true;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">// 创建工作者线程失败</span><br><span class="line">         if (! workerStarted)</span><br><span class="line">	// 回滚工作线程创建。从工作线程set中移除工作工作线程（如果存在）减少工作线程数量，试图中断线程池</span><br><span class="line">             addWorkerFailed(w);</span><br><span class="line">     &#125;</span><br><span class="line">     return workerStarted;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><p>首先看Worker类的注释<br>Worker 主要维护运行任务的线程的中断控制状态，以及其他次要簿记。此类适时地扩展了 AbstractQueuedSyncer，以简化获取和释放围绕每个任务执行的锁。这可以防止旨在唤醒等待任务的工作线程而不是中断正在运行的任务的中断。我们实现了一个简单的非重入互斥锁，而不是使用 ReentrantLock，因为我们不希望工作线程的任务再调用线程池控制方法（如 setCorePoolSize）时能够重新获取锁。此外，为了在线程实际开始运行任务之前抑制中断，我们将锁定状态初始化为负值(Worker构造方法初始化state为-1)，并在启动时将其清除（在 runWorker 中，有一行代码是w.unlock()该方法中调用了tryRelease(1),被Worker重写，setState(0) ）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   private final class Worker extends AbstractQueuedSynchronizer</span><br><span class="line">       implements Runnable&#123;</span><br><span class="line">	</span><br><span class="line">	private static final long serialVersionUID = 6138294804551838833L;</span><br><span class="line">	</span><br><span class="line">	final Thread thread;</span><br><span class="line">	</span><br><span class="line">	Runnable firstTask;</span><br><span class="line">	</span><br><span class="line">	volatile long completedTasks;</span><br><span class="line">	</span><br><span class="line">	Worker(Runnable firstTask) &#123;</span><br><span class="line">           setState(-1); // inhibit interrupts until runWorker</span><br><span class="line">           this.firstTask = firstTask;</span><br><span class="line">           this.thread = getThreadFactory().newThread(this);</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">	public void run() &#123;</span><br><span class="line">           runWorker(this);</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">       protected boolean tryRelease(int unused) &#123;</span><br><span class="line">           setExclusiveOwnerThread(null);</span><br><span class="line">           setState(0);</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">	···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Worker实现了Runnable接口，Worker也是一个线程任务，Worker构造方法中调用线程工厂的newThread方法传入this，即线程的任务就是自己。故addWorker方法源码中可以看到t.start，会触发Worker类的run方法被JVM调用。<br>此外Worker继承了AQS，就是为了能够改变线程的状态，控制线程的中断，使空闲线程可以响应中断，执行任务的线程不能响应中断<br>构造方法初始化Worker的时候state&#x3D;-1 就是为了让任务在开始执行前禁止中断</p>
<h4 id="Worker-runWorker方法"><a href="#Worker-runWorker方法" class="headerlink" title="Worker#runWorker方法"></a>Worker#runWorker方法</h4><p>首先看该方法的注释<br>1、我们可能会从初始任务开始，在这种情况下，我们不需要获得第一个任务。否则，只要池正在运行，我们就从getTask获取任务。如果它返回 null，则工作线程由于池状态或配置参数更改而退出。其他退出是由外部代码中的异常抛出引起的，在这种情况下，complete突然持有，这通常会导致processWorkerExit替换此线程。<br>2、在运行任何任务之前，获取锁以防止在执行任务时发生线程池中断，然后我们确保除非池停止，否则该线程没有设置其中断。<br>3、每次任务运行之前都会调用 beforeExecute，这可能会引发异常，在这种情况下，我们会导致线程死亡（断开循环，完成突然为 true），而不处理任务。<br>4、假设 beforeExecute 正常完成，我们运行任务，收集任何抛出的异常以发送到 afterExecute。我们分别处理 RuntimeException、Error（规范保证我们捕获这两个错误）和任意 Throwable。因为我们无法在 Runnable.run 中重新抛出 Throwable，所以我们将它们包装在 Errors 中（到线程的 UncaughtExceptionHandler）。任何抛出的异常也保守地导致线程死亡。<br>5、task.run 完成后，我们调用 afterExecute，这也可能会抛出异常，这也会导致线程死亡。根据 JLS Sec 14.20，即使 task.run 抛出，此异常也会生效。异常机制的净效果是，afterExecute 和线程的 UncaughtExceptionHandler 具有尽可能准确的信息，我们可以提供有关用户代码遇到的任何问题的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  final void runWorker(Worker w) &#123;</span><br><span class="line">      Thread wt = Thread.currentThread();</span><br><span class="line">      Runnable task = w.firstTask;</span><br><span class="line">      w.firstTask = null;</span><br><span class="line">// 把Worker初始化时候设定的state=-1(表示不可中断)改为0(表示可以中断)</span><br><span class="line">      w.unlock();</span><br><span class="line">      boolean completedAbruptly = true;</span><br><span class="line">      try &#123;</span><br><span class="line">	//执行Worker的task或者从队列中获取任务，只要获取的任务不是null 就一直循环取任务执行</span><br><span class="line">          while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">		// 执行任务前加锁，防止线程被其他线程中断</span><br><span class="line">              w.lock();</span><br><span class="line">              // 如果线程池停止了，当前线程未中盾，就中断当前线程</span><br><span class="line">              if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                   (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                  !wt.isInterrupted())</span><br><span class="line">                  wt.interrupt();</span><br><span class="line">              try &#123;</span><br><span class="line">			// 执行任务前的回调 这是个扩展，可以通过继续线程池重写方法(要记得在重写方法的最后加上super.beforeExecute())</span><br><span class="line">                  beforeExecute(wt, task);</span><br><span class="line">			// 提前定义任务执行可能抛出的异常</span><br><span class="line">                  Throwable thrown = null;</span><br><span class="line">                  try &#123;</span><br><span class="line">				// 真正的任务执行;注意如果要执行的是FutureTask的run()是不会捕获任何异常的</span><br><span class="line">				// 因为FutureTask的run方法内部捕获了异常之后并没有显示抛出，而是把异常放到setException(ex)中了</span><br><span class="line">                      task.run();</span><br><span class="line">                  &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                      thrown = x; throw x;// 抛出异常</span><br><span class="line">                  &#125; catch (Error x) &#123;</span><br><span class="line">                      thrown = x; throw x;// 抛出异常</span><br><span class="line">                  &#125; catch (Throwable x) &#123;</span><br><span class="line">                      thrown = x; throw new Error(x);// 抛出异常</span><br><span class="line">                  &#125; finally &#123;</span><br><span class="line">			    // 执行任务后的回调 也是个扩展 并且注释上给了完美的示例</span><br><span class="line">                      afterExecute(task, thrown);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; finally &#123;</span><br><span class="line">                  task = null;</span><br><span class="line">                  w.completedTasks++;</span><br><span class="line">			// 释放锁</span><br><span class="line">                  w.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          completedAbruptly = false;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">	// 处理工作线程退出</span><br><span class="line">          processWorkerExit(w, completedAbruptly);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>简单总结一下：进入这个方法说明开始执行任务了，先执行的是firstTask，也就是Worker自身携带的任务(一类是线程数小于核心线程数，提交任务创建核心线程后直接执行；一类是线程数超过核心线程数但没超过最大线程数，队列也满了，提交任务后创建非核心线程直接执行)，自带的任务执行完了，Worker并没有销毁而是继续循环调用getTask方法从队列中获取任务来执行，执行前先加锁，避免被别的线程中断，然后执行task.run方法真正的执行任务，如果任务有异常就抛出(这里特别说明如果任务是FutureTask类型的，执行过程中有异常了这里是捕获不到的，因为FutureTask的run方法内会捕获异常但不throw而是把异常放到setException(ex)中了，通过Future的get方法可以拿到异常)，最后释放锁，进行下一轮循环。这不就体现了线程复用(一个任务执行完了线程并没有销毁或中断，而是继续循环从队列获取任务执行)</p>
<h4 id="ThreadPoolExecutor-getTask方法"><a href="#ThreadPoolExecutor-getTask方法" class="headerlink" title="ThreadPoolExecutor#getTask方法"></a>ThreadPoolExecutor#getTask方法</h4><p>先看一下注释：<br>根据当前配置设置对任务执行阻塞或定时等待，如果此工作线程由于以下任何原因必须退出，则返回 null：1. 有超过 maximumPoolSize 工作线程（由于调用 setMaximumPoolSize）。2. 线程池池停止。3. 线程池关闭，队列为空。4. 此工作线程在等待任务时超时，超时工作线程在定时等待之前和之后都会被终止（即 allowCoreThreadTimeOut || workerCount &gt; corePoolSize），如果队列为非空，则此工作线程不是池中的最后一个线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">       boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           int c = ctl.get();</span><br><span class="line">           int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           // 如果线程池关闭或者队列为空 就减少工作线程 返回null</span><br><span class="line">           if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">               decrementWorkerCount();</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">		// 获取工作线程的数量</span><br><span class="line">           int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">           // 是否允许核心线程超时回收默认是false(即使空闲也不会被回收，改为true，核心线程会等待keepAliveTime时间，如果超时就回收)</span><br><span class="line">		// 为true 说明核心线程可以超时回收 或者 工作线程超过了核心线程数</span><br><span class="line">		// 为false 说明核心线程一直存活 且 工作线程没有超过核心线程数</span><br><span class="line">           boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">		</span><br><span class="line">		// 能进入if分支的情况</span><br><span class="line">		// 1、工作线程超过了最大线程数</span><br><span class="line">		// 2、核心线程就1个在执行需要很长时间的任务且允许核心线程超时且队列为空</span><br><span class="line">           if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">               &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">			// 原子方式减少工作线程数量</span><br><span class="line">               if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                   return null;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           try &#123;</span><br><span class="line">			// 设置了核心线程允许超时回收 则在存活时间内从队列poll任务</span><br><span class="line">			// 没有设置，调用workQueue的take方法阻塞在当前。队列中有任务加入时，线程被唤醒，take方法返回任务，并执行。</span><br><span class="line">               Runnable r = timed ?</span><br><span class="line">                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                   workQueue.take();</span><br><span class="line">               if (r != null)</span><br><span class="line">                   return r;</span><br><span class="line">               timedOut = true;</span><br><span class="line">           &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">               timedOut = false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>核心线程的会一直卡在workQueue.take方法，被阻塞并挂起，不会占用CPU资源，直到拿到Runnable 然后返回。如果allowCoreThreadTimeOut设置为true,核心线程就会去调用poll方法，因为poll可能会返回null,所以这时候核心线程满足超时条件也会被销毁。</p>
<p>非核心线程会workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ，如果超时还没有拿到，下一次循环判断compareAndDecrementWorkerCount就会返回null,Worker对象的run()方法调用runWorker方法的循环体的判断为null,任务结束，然后执行processWorkerExit方法回收线程 。</p>
<h4 id="submit吞噬异常和ececute抛出异常："><a href="#submit吞噬异常和ececute抛出异常：" class="headerlink" title="submit吞噬异常和ececute抛出异常："></a>submit吞噬异常和ececute抛出异常：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 提交Runnable 包装RunnableFuture时候默认值是null</span><br><span class="line">   public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">       if (task == null) throw new NullPointerException();</span><br><span class="line">       RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br><span class="line">       execute(ftask);</span><br><span class="line">       return ftask;</span><br><span class="line">   &#125;</span><br><span class="line">// 提交Runnable 包装RunnableFuture时候默认值是传的值result</span><br><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;</span><br><span class="line">       if (task == null) throw new NullPointerException();</span><br><span class="line">       RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">       execute(ftask);</span><br><span class="line">       return ftask;</span><br><span class="line">   &#125;</span><br><span class="line">// 提交Callable 包装RunnableFuture不需要默认值</span><br><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">       if (task == null) throw new NullPointerException();</span><br><span class="line">       RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">       execute(ftask);</span><br><span class="line">       return ftask;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到使用submit提交的任务都被包装成了RunnableFuture，最后都是执行的execute(ftask)方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 包装Runnable 有默认值就使用，没有就是null</span><br><span class="line">   protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;</span><br><span class="line">       return new FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">   &#125;</span><br><span class="line">// 包装Callable</span><br><span class="line">   protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;</span><br><span class="line">       return new FutureTask&lt;T&gt;(callable);</span><br><span class="line">   &#125;	</span><br></pre></td></tr></table></figure>
<p>可以看到使用submit提交的任务都被包装成了RunnableFuture具体是FutureTask</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Runnable的包装还没有看到最后呢</span><br><span class="line">   public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">       this.callable = Executors.callable(runnable, result);</span><br><span class="line">       this.state = NEW;       // ensure visibility of callable</span><br><span class="line">   &#125;</span><br><span class="line">// Callable类型的任务包装到这里就完事了 后续等待线程执行FutureTask的run方法就会调用callable的call方法</span><br><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">       if (callable == null)</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       this.callable = callable;</span><br><span class="line">       this.state = NEW;       // ensure visibility of callable</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Callable的任务到这里就被彻底包装为FutureTask，FutureTask是Runnable的实现类。而Runnable方法则是调用了Executors.callable(runnable, result)方法来转换为callable,底层是调用new RunnableAdapter<T>(task, result)来实现转换的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;</span><br><span class="line">      final Runnable task;</span><br><span class="line">      final T result;</span><br><span class="line">// 赋值了task 赋值了默认值result</span><br><span class="line">      RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">          this.task = task;</span><br><span class="line">          this.result = result;</span><br><span class="line">      &#125;</span><br><span class="line">// 线程执行方法call方法</span><br><span class="line">      public T call() &#123;</span><br><span class="line">	//执行任务的run方法</span><br><span class="line">          task.run();</span><br><span class="line">	// 返回的默认值</span><br><span class="line">          return result;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Runnable类型的任务最终被转换为了Callable，且在call方法中真正执行自己的run方法，还把预设的默认值返回了回去，使用Future的get方法获取的就是默认值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(this, runnerOffset,</span><br><span class="line">                                     null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">	// 执行FutureTask的callable的call方法，并获取返回值</span><br><span class="line">	// 比对上面的Runnable转换Callable时候，所赋的默认值result，就是这里获取到的</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">	// 捕获异常后并没有throw而是放到了setException中</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">	// FutureTask的set方法 set的就是result</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // runner must be non-null until state is settled to</span><br><span class="line">        // prevent concurrent calls to run()</span><br><span class="line">        runner = null;</span><br><span class="line">        // state must be re-read after nulling runner to prevent</span><br><span class="line">        // leaked interrupts</span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到FutureTask的run方法中去调用了FutureTask的callable的call方法，得到call方法的返回值result之后，调用set(result)方法存储了result，如果call方法除了异常，并没有throw而是调用setException方法中，这就是为什么submit方法捕获不到异常的原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   protected void setException(Throwable t) &#123;</span><br><span class="line">       if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">		// call方法被捕获的异常，赋值给了outcome</span><br><span class="line">           outcome = t;</span><br><span class="line">           UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state</span><br><span class="line">           finishCompletion();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   protected void set(V v) &#123;</span><br><span class="line">       if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">		// call方法的执行结果，赋值给了outcome</span><br><span class="line">           outcome = v;</span><br><span class="line">           UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state</span><br><span class="line">           finishCompletion();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Future的get方法被FutureTask重写</span><br><span class="line">   public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">       int s = state;</span><br><span class="line">       if (s &lt;= COMPLETING)</span><br><span class="line">           s = awaitDone(false, 0L);</span><br><span class="line">	// 通过report方法获取结果	</span><br><span class="line">       return report(s);</span><br><span class="line">   &#125;</span><br><span class="line">   private V report(int s) throws ExecutionException &#123;</span><br><span class="line">	// 获取FutureTask的outcome</span><br><span class="line">       Object x = outcome;</span><br><span class="line">       if (s == NORMAL)</span><br><span class="line">		// 返回结果 outcome</span><br><span class="line">           return (V)x;</span><br><span class="line">       if (s &gt;= CANCELLED)</span><br><span class="line">           throw new CancellationException();</span><br><span class="line">       throw new ExecutionException((Throwable)x);</span><br><span class="line">   &#125;	</span><br></pre></td></tr></table></figure>
<p>可以看到无论是异常信息还是正常的返回结果都是被赋值给了FutureTask的outcome，而使用Future的get方法获取的结果就是outcome，所以Future的get方法得到的值可能是正常结果也可能是异常信息。</p>
<p>execute方法提交到线程池的任务都是被包装成Worker，线程执行的时候走的是Worker中的run方法，调用runWorker方法，在runWorker方法执行task.run()发生异常被捕获后都会被throw，所以可以在外部被捕获。submit方法提交到线程池的任务都被包装成FutureTask,然后调用execute(ftask),被包装成Worker，线程执行的时候走的是Worker中的run方法，调用runWorker方法，在runWorker方法执行task.run(),进而执行FutureTask的run方法，该方法捕获到异常后没有throw(这就造成”异常吞噬”现象)，而是通过setException方法把异常信息放到FutureTask的outcome中，要想获得异常信息，需要用submit返回的Future对象的get方法来获取，get方法底层是获取的outcome。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。注意，这一步需要获得全局锁。<br>线程总数量 &gt;&#x3D; corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）。<br>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些”临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。注意，这一步需要获得全局锁。<br>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取拒绝策略进行处理。</p>
<p>两种情况会拒绝处理任务：<br>当线程数已经达到maxPoolSize，且队列已满，会拒绝新任务<br>当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务</p>
<h2 id="看完以后"><a href="#看完以后" class="headerlink" title="看完以后"></a>看完以后</h2><p>点赞，点赞是免费的，但却能激励我保持创作，还能帮助更多的人看到这篇文章。</p>
<p>留言，有任何问题，都可以在评论区留言，我会尽可能回复。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xuchao6969.github.io">xuchao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xuchao6969.github.io/2022/05/03/ThreadPool/">https://xuchao6969.github.io/2022/05/03/ThreadPool/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xuchao6969.github.io" target="_blank">xuchaoのblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/juc/">juc</a></div><div class="post_share"><div class="social-share" data-image="/img/leiwujie2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/08/01/DesignPatternOfSingleton/"><img class="next-cover" src="/img/xiaose4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">单例模式</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/leiwujie1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xuchao</div><div class="author-info__description">记录一下工作学习生活上的分享~~~ </div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xuchao6969"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xuchao6969" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xucha_o@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Future%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E6%B3%A8%E6%84%8F"><span class="toc-number">1.</span> <span class="toc-text">Future使用姿势注意</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FutureTask%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E6%B3%A8%E6%84%8F"><span class="toc-number">2.</span> <span class="toc-text">FutureTask使用姿势注意</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPooolExecutor-execute%E6%96%B9%E6%B3%95%E8%B5%8F%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">ThreadPooolExecutor#execute方法赏析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">3.1.</span> <span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E5%8F%82%E6%95%B0%E6%9C%80%E5%85%A8%E7%9A%84"><span class="toc-number">3.2.</span> <span class="toc-text">构造方法(参数最全的)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E5%85%A5%E5%8F%A3"><span class="toc-number">3.3.</span> <span class="toc-text">线程池执行任务入口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addWorker%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">addWorker方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Worker%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">Worker类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Worker-runWorker%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.3.</span> <span class="toc-text">Worker#runWorker方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadPoolExecutor-getTask%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.4.</span> <span class="toc-text">ThreadPoolExecutor#getTask方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#submit%E5%90%9E%E5%99%AC%E5%BC%82%E5%B8%B8%E5%92%8Cececute%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%9A"><span class="toc-number">3.3.5.</span> <span class="toc-text">submit吞噬异常和ececute抛出异常：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E5%AE%8C%E4%BB%A5%E5%90%8E"><span class="toc-number">4.</span> <span class="toc-text">看完以后</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/17/BurnTheRope/" title="一根不均匀的绳子，全部烧完需要1个小时，问怎样烧能计时1个小时15分钟"><img src="/img/yuhan1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一根不均匀的绳子，全部烧完需要1个小时，问怎样烧能计时1个小时15分钟"/></a><div class="content"><a class="title" href="/2023/03/17/BurnTheRope/" title="一根不均匀的绳子，全部烧完需要1个小时，问怎样烧能计时1个小时15分钟">一根不均匀的绳子，全部烧完需要1个小时，问怎样烧能计时1个小时15分钟</a><time datetime="2023-03-17T08:30:21.000Z" title="发表于 2023-03-17 16:30:21">2023-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/16/NucleicAcidDetection/" title="核酸检测混检为什么采用1管10个样本进行检查"><img src="/img/lihanyi.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="核酸检测混检为什么采用1管10个样本进行检查"/></a><div class="content"><a class="title" href="/2023/03/16/NucleicAcidDetection/" title="核酸检测混检为什么采用1管10个样本进行检查">核酸检测混检为什么采用1管10个样本进行检查</a><time datetime="2023-03-16T10:20:51.000Z" title="发表于 2023-03-16 18:20:51">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/21/SpringCloudAlibabaSeata/" title="SpringCloudAlibaba Seata实现分布式事务"><img src="/img/xiaose5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloudAlibaba Seata实现分布式事务"/></a><div class="content"><a class="title" href="/2023/01/21/SpringCloudAlibabaSeata/" title="SpringCloudAlibaba Seata实现分布式事务">SpringCloudAlibaba Seata实现分布式事务</a><time datetime="2023-01-21T10:11:51.000Z" title="发表于 2023-01-21 18:11:51">2023-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/HexoConfigGiscus/" title="Hexo+Butterfly配置Giscus评论"><img src="/img/leiwujie.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo+Butterfly配置Giscus评论"/></a><div class="content"><a class="title" href="/2022/11/21/HexoConfigGiscus/" title="Hexo+Butterfly配置Giscus评论">Hexo+Butterfly配置Giscus评论</a><time datetime="2022-11-21T09:09:25.000Z" title="发表于 2022-11-21 17:09:25">2022-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/HexoBlogBackup/" title="Hexo 博客备份"><img src="/img/leiwujie1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo 博客备份"/></a><div class="content"><a class="title" href="/2022/11/21/HexoBlogBackup/" title="Hexo 博客备份">Hexo 博客备份</a><time datetime="2022-11-21T09:09:25.000Z" title="发表于 2022-11-21 17:09:25">2022-11-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/leiwujie2.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> xuchao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadGiscus () {
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'xuchao6969/blog_giscus',
    'data-repo-id': 'R_kgDOIMjKeA',
    'data-category-id': 'DIC_kwDOIMjKeM4CR7sR',
    'data-mapping': 'pathname',
    'data-theme': nowTheme,
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme () {
  const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }

  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}

if ('Giscus' === 'Giscus' || !false) {
  if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>