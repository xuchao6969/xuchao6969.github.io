<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring transaction manager | xuchaoのblog</title><meta name="keywords" content="spring"><meta name="author" content="xuchao"><meta name="copyright" content="xuchao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring transaction manager什么是transactiontransaction四六级单词：交易、成交、事务计算机中是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，如果有一个失败则在每个操作中所做的所有更改都会被撤消，是并发控制的单元。在平时的开发中，我们经常处理某个业务，该业务涉及到n(n&gt;&#x3D;2)张表的数据的写操作(增删改)，在业务逻辑中，必">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring transaction manager">
<meta property="og:url" content="https://xuchao6969.github.io/2022/10/04/SpringTransactionManager/index.html">
<meta property="og:site_name" content="xuchaoのblog">
<meta property="og:description" content="Spring transaction manager什么是transactiontransaction四六级单词：交易、成交、事务计算机中是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，如果有一个失败则在每个操作中所做的所有更改都会被撤消，是并发控制的单元。在平时的开发中，我们经常处理某个业务，该业务涉及到n(n&gt;&#x3D;2)张表的数据的写操作(增删改)，在业务逻辑中，必">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xuchao6969.github.io/img/wuxin1.jpg">
<meta property="article:published_time" content="2022-10-04T10:20:51.000Z">
<meta property="article:modified_time" content="2023-03-30T16:02:23.677Z">
<meta property="article:author" content="xuchao">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xuchao6969.github.io/img/wuxin1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xuchao6969.github.io/2022/10/04/SpringTransactionManager/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50000,"languages":{"author":"作者: xuchao","link":"链接: ","source":"来源: xuchaoのblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring transaction manager',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-31 00:02:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/leiwujie1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/wuxin1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">xuchaoのblog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring transaction manager</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-04T10:20:51.000Z" title="发表于 2022-10-04 18:20:51">2022-10-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-30T16:02:23.677Z" title="更新于 2023-03-31 00:02:23">2023-03-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>62分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Spring-transaction-manager"><a href="#Spring-transaction-manager" class="headerlink" title="Spring transaction manager"></a>Spring transaction manager</h2><h2 id="什么是transaction"><a href="#什么是transaction" class="headerlink" title="什么是transaction"></a>什么是transaction</h2><p>transaction四六级单词：交易、成交、事务<br>计算机中是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，如果有一个失败则在每个操作中所做的所有更改都会被撤消，是并发控制的单元。在平时的开发中，我们经常处理某个业务，该业务涉及到n(n&gt;&#x3D;2)张表的数据的写操作(增删改)，在业务逻辑中，必须保证对这n张表的写操作成功执行，如果有一个执行错误，该业务就执行失败。</p>
<blockquote>
<p>说个不恰当的例子，但是很形象：一手交钱一手交货<br>付了钱，拿到货，这就是一个成功执行的事务；交易-&gt;成交<br>付了钱，没拿到货，你肯定不乐意，事务执行失败；交易-&gt;作废<br>没给钱，拿到货，空手套白狼肯定不行，虽然你乐意，商家不乐意了，事务执行失败；交易-&gt;作废<br>没给钱，没拿到货，这也可以看作是一个成功的事务；交易-&gt;成交</p>
</blockquote>
<h2 id="事务的四个特性ACID"><a href="#事务的四个特性ACID" class="headerlink" title="事务的四个特性ACID"></a>事务的四个特性ACID</h2><p>1、原子性(Atomicity)： 事务是数据库的逻辑工作单位，事务中执行的指令操作要么全部成功，要么全部失败，这是一个单元(原子)。<br>2、一致性(Consistency)： 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。<br>3、隔离性(Isolation)： 一个事务的执行不能被其他事务干扰。在并发执行数据库操作同一张表的两个事务A和B，事务B要么是在A提交前执行完成，要么实在A提交后才开始执行<br>4、持续性&#x2F;永久性(Durability)： 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</p>
<h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p>1、什么是事务传播行为<br>官方回答：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.23/reference/html/data-access.html#transaction">官方引用文档</a></p>
<blockquote>
<p>Propagation: Typically, all code within a transaction scope runs in that transaction. However, you can specify the behavior if a transactional method is run when a transaction context already exists. For example, code can continue running in the existing transaction (the common case), or the existing transaction can be suspended and a new transaction created.<br>传播。通常情况下，一个事务范围内的所有代码都在该事务中运行。然而，如果一个事务性方法在一个已经存在的事务上下文中被运行，你可以指定其行为。例如，代码可以继续在现有的事务中运行（常见的情况），或者暂停现有的事务并创建一个新的事务。</p>
</blockquote>
<p>2、有哪些事务传播行为<br>官方使用文档只介绍了3种分别是required、required_new、nested 具体可以参考上边官网的1.4.7节。我们通常八股文面试不都是说传播行为有7种么，哪7种呢，答案就在TransactionDefinition类中。 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.23/javadoc-api/">官方api文档</a></p>
<p>支持当前事务的：</p>
<ul>
<li>PROPAGATION_REQUIRED：支持当前事务，如果不存在，则创建一个新的。这是spring的事务传播行为的默认设置</li>
<li>PROPAGATION_SUPPORTS：支持当前事务，如果不存在，则以非事务方式执行。对于具有事务同步的事务管理器，PROPAGATION_SUPPORTS 与完全没有事务略有不同，因为它定义了同步可能适用的事务范围。因此，相同的资源（JDBC 连接、Hibernate 会话等）将在整个指定范围内共享。请注意，确切的行为取决于事务管理器的实际同步配置！小心使用 PROPAGATION_SUPPORTS！特别是，不要依赖 PROPAGATION_SUPPORTS 范围内的 PROPAGATION_REQUIRED 或 PROPAGATION_REQUIRES_NEW(这可能会导致运行时同步冲突),如果这种嵌套是不可避免的，请确保适当地配置您的事务管理器(通常切换到”实际事务同步”) </li>
<li>PROPAGATION_MANDATORY：支持当前事务，如果当前事务不存在则抛出异常。需要注意的是PROPAGATION_MANDATORY 范围内的事务同步将始终由周围的事务驱动</li>
</ul>
<p>不支持当前事务的：</p>
<ul>
<li>PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。注意：PROPAGATION_REQUIRES_NEW 作用域总是定义它自己的事务同步。现有的同步将适当地暂停和恢复</li>
<li>PROPAGATION_NOT_SUPPORTED：不支持当前事务,而是始终以非事务方式执行</li>
<li>PROPAGATION_NEVER：不支持当前事务,如果当前存在事务，则抛出异常</li>
<li>PROPAGATION_NESTED：如果当前事务存在，则在嵌套事务中执行，否则表现得像 PROPAGATION_REQUIRED</li>
</ul>
<h2 id="事务执行的过程"><a href="#事务执行的过程" class="headerlink" title="事务执行的过程"></a>事务执行的过程</h2><p>来自官网的图<br><img src="/img/SpringTransactionManager/tx1.png"/></p>
<ol>
<li>发起业务方法的调用，进入AopProxy，触发代理对象的方法调用，而不是目标方法<br>引起事务失效的第一个考点：事务方法不是pulic的。因为aop创建代理的时候必须要有访问权限private、default什么的肯定不行，代理都创建不了，事务肯定失效。官网也在1.4.6 Using @Transactionl小节Method visibility and @Transactional 中有说明。</li>
<li>进入Transaction Advisor 事务监控器，触发创建事务，可以对事务进行一些配置，比如propagation事务传播行为、isolation隔离级别、rollbackFor回滚针对那些异常等，官网在1.4.6小节的第一子节@Transactional Settings中有详细介绍</li>
<li>进入Custome Advisor，自定义的拦截器，可以对方法进行一些前置增强，比如在方法执行前记录入参、输出日志之类的。</li>
<li>执行Target Method目标方法,处理业务逻辑，可能执行成功或发生异常<br>引起事务失效的第二个考点：业务代码中有try catch，且try代码块中发生了RuntimeException异常或者子类异常，这时候try代码块中的业务代码就脱离了spring的事务管理，如需使事务生效，需要在catch代码块中将异常信息显示的抛出来throw new RuntimeException(“xxx”)</li>
<li>进入Custome Advisor，自定义的拦截器，可以对方法进行一些后置增强，比如在方法执行后记录结果、输出日志之类的。</li>
<li>进入Transaction Advisor 事务监控器，根据目标方法的执行情况触发事务的提交或者回滚，如果目标方法执行成功，提交事务，如果目标方法抛出了unchecked异常(spring默认的)，事务回滚</li>
<li>把事务的执行结果返回给代理对象，结果包括成功或者异常信息</li>
<li>代理对象拿到结果后返回给调用者</li>
</ol>
<p>从此图也可以看到事务的边界是在调用业务方法之前开始的，业务方法执行完毕之后来执行commit or rollback(Spring默认取决于是否抛出RuntimeException)。官网的事务回滚规则在1.4.3小节。</p>
<h2 id="事务的使用例子"><a href="#事务的使用例子" class="headerlink" title="事务的使用例子"></a>事务的使用例子</h2><p><a target="_blank" rel="noopener" href="https://github.com/xuchao6969/demo/tree/master/spring-transaction">demo地址:</a> 在src&#x2F;main&#x2F;java&#x2F;com&#x2F;xc&#x2F;springtransaction&#x2F;下<br>测试例子使用的是controller中的代码<br>源码分析主要使用SpringTransactionApplication.java中的代码</p>
<p>这里只展示service层的测试代码，以及测试条件和测试结果(写在在注释上)<br>因为要测试代理对象的方法调用对事务的影响，所以servic层上开启了AspecJ的代理@EnableAspectJAutoProxy(exposeProxy &#x3D; true)<br>需要引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>如果不想引入AspectJ，测试代理对象的方法，可以把service本身注入进来</p>
<ul>
<li>测试一<img src="/img/SpringTransactionManager/test1.png"/></li>
<li>测试二<img src="/img/SpringTransactionManager/test2.png"/></li>
<li>测试三<img src="/img/SpringTransactionManager/test3.png"/></li>
<li>测试四<img src="/img/SpringTransactionManager/test4.png"/></li>
<li>测试五<img src="/img/SpringTransactionManager/test5.png"/></li>
<li>测试六<img src="/img/SpringTransactionManager/test6.png"/></li>
<li>测试七<img src="/img/SpringTransactionManager/test7.png"/></li>
<li>测试八<img src="/img/SpringTransactionManager/test8.png"/></li>
<li>测试九<img src="/img/SpringTransactionManager/test9.png"/></li>
<li>测试十<img src="/img/SpringTransactionManager/test10.png"/></li>
<li>测试十一<img src="/img/SpringTransactionManager/test11.png"/></li>
<li>测试十二<img src="/img/SpringTransactionManager/test12.png"/></li>
<li>测试十三<img src="/img/SpringTransactionManager/test13.png"/>
<img src="/img/SpringTransactionManager/test13_1.png"/></li>
<li>测试十四<img src="/img/SpringTransactionManager/test14.png"/></li>
<li>测试十五<img src="/img/SpringTransactionManager/test15.png"/>
<img src="/img/SpringTransactionManager/test15_1.png"/></li>
</ul>
<blockquote>
<p>测试四：外层事务传播行为是required(spring默认的)，内层的两个子方法的事务传播行为都是requires_new，程序进入到test4方法的时候就已经开启了一个事务，走到两个子方法时，发现test4已经开启了一个事务，就会把它挂起，两个子方法各自新建自己的事务，等两个子方法的事务完成以后，被挂起的test4的事务才会继续执行。 因为是相互独立的事务，所以saveTrueWithTransactionAnnotation事务自己提交，即使saveFalseWithTransactionAnnotation触发异常也只是回滚自己开启的事务，test4的事务也不会回滚，也不会影响到saveTrueWithTransactionAnnotation的事务结果。另外，如果对saveFalseWithTransactionAnnotation方法加上try catch并捕获它抛出的异常，test4的事务也是有可能会提交的(如果捕获的异常不是test4指定的回滚异常)</p>
</blockquote>
<p>这种情况下需要注意死锁问题：主方法是required，子方法的是requires_new，主事务被挂起，子事务要加的锁被主事务占用，就发生死锁了</p>
<blockquote>
<p>测试五和测试九可以发现：外层方法不加@Transactional，子方法即使有@Transactional，如果是this调用没有走代理，事务是不起作用的，即使出现异常也不回滚。</p>
</blockquote>
<blockquote>
<p>测试七：外层事务传播行为是required(spring默认的)，内层的两个子方法的事务传播行为都是required，程序进入到test7方法的时候就已经开启了一个事务，走到两个子方法时，子方法发现已经有一个事务了，就不会在新建事务，而是加入到test7建的事务中，不管是test7方法自己异常了，还是子方法异常了，都会回滚。</p>
</blockquote>
<blockquote>
<p>测试十一：外层事务传播行为是required(spring默认的)，内层子方法的事务传播行为是supports，程序进入到test11方法的时候就已经开启了一个事务，走到子方法时，子方法发现已经有一个事务了就加入到test11建的事务中，无论是子方法抛异常，还是test11方法抛异常，都会回滚</p>
</blockquote>
<blockquote>
<p>测试十二：没有外层事务，内层子方法的事务传播行为是supports，程序进入到test12方法，走到子方法时，子方法发现没有事务，就按照无事务处理正常执行，有异常也不回滚</p>
</blockquote>
<blockquote>
<p>测试十三：外层事务传播行为是required(spring默认的)，saveTrueWithTransactionAnnotation方法的传播行为是required，saveFalseWithTransactionAnnotation方法的传播行为是nested，程序执行的时候走到test13会先创建事务，走到saveTrueWithTransactionAnnotation方法时候，发现已经存在一个test13创建的事务了，于是加入进来，程序继续进行，走到saveFalseWithTransactionAnnotation方法时候，创建一个新的事务Nested事务，不过这个事务归test13创建的事务管理，Nested事务不能自己提交，只有当test13创建的事务提交后他才执行提交，如果Nested事务有异常可以自己回滚，并且会把异常抛给test13的事务，如果test13的事务catch了这个异常，test13的事务不会回滚，如图中所示，并没有影响到saveTrueWithTransactionAnnotation的事务结果，否则test13也会回滚(把try-catch去掉 全部回滚)。如果外层方法中出现异常，则<br>saveTrueWithTransactionAnnotation方法，saveFalseWithTransactionAnnotation方法全部都回滚<br>日志分析：<br>1、程序走到test13方法，准备创建事务test13<br>2、从数据库连接@104fe42b中创建事务test13<br>3、把数据库链接@104fe42b中的事务改为手动提交<br>4、程序走到saveTrueWithTransactionAnnotation方法，传播行为是required，发现已经存在事务test13了，就加入test13中<br>5、程序走到saveFalseWithTransactionAnnotation方法，传播行为是nested，创建嵌套事务，注意这里并没有 没有 没有从别的数据库链接中创建(和下边测试十五的require_new进行区分)，还是从数据库链接@104fe42b中进行创建嵌套事务saveFalseWithTransactionAnnotation，不过这个事务归test13事务管理<br>6、程序发现saveFalseWithTransactionAnnotation方法中有异常，标记回滚到savepoint安全点,也就是数据库数据状态恢复到执行这个方法之前<br>7、程序回到test13方法，子方法都走完了，准备发起事务提交<br>8、提交数据库链接@104fe42b中的事务也就是事务test13，细节：saveTrueWithTransactionAnnotation创建的事务加入到test13事务中，这部分会commit。test13管理的嵌套事务saveFalseWithTransactionAnnotation则会回滚<br>9、事务结束后释放链接@104fe42b</p>
</blockquote>
<blockquote>
<p>测试十四：主方法子方法事务传播行为都是required，主方法test14创建事务，两个子方法都加入到test14事务中，saveFalseWithTransactionAnnotation方法执行错误，整个事务回滚</p>
</blockquote>
<blockquote>
<p>测试十五：该效果和测试十三一样,但是细节不一样，外层事务传播行为是required(spring默认的)，saveTrueWithTransactionAnnotation方法的传播行为是required，saveFalseWithTransactionAnnotation方法的传播行为是requires_new，程序执行的时候走到test15会先创建事务，走到saveTrueWithTransactionAnnotation方法时候，发现已经存在一个test15创建的事务了，于是加入进来，程序继续进行，走到saveFalseWithTransactionAnnotation方法时候，发现已经有事务test15了，挂起test15事务，创建一个新的saveFalseWithTransactionAnnotation事务，saveFalseWithTransactionAnnotation事务发现程序有异常，就回滚，然后把挂起的test15程序恢复过来继续执行，提交test15事务，被加入test15中的saveTrueWithTransactionAnnotation事务执行了commit<br>日志分析：<br>1、程序走到test15方法，准备创建事务test15<br>2、从数据库连接@33457292中创建事务test15<br>3、把数据库链接@33457292中的事务改为手动提交<br>4、程序走到saveTrueWithTransactionAnnotation方法，传播行为是required，发现已经存在事务test15了，就加入test15中<br>5、程序走到saveFalseWithTransactionAnnotation方法，传播行为是required_new，发现已经存在test15事务了，就把他挂起，准备创建新的事务saveFalseWithTransactionAnnotation<br>6、从另一个数据库连接@359047dc中创建事务saveFalseWithTransactionAnnotation<br>7、把数据库链接@359047dc中的事务改为手动提交<br>8、程序发现saveFalseWithTransactionAnnotation方法中有异常，标记回滚，准备回滚<br>9、回滚数据库连接@359047dc中创建的事务saveFalseWithTransactionAnnotation<br>10、事务saveFalseWithTransactionAnnotation回滚后，释放数据库连接@359047dc<br>11、将挂起的事务test15恢复<br>12、准备提交事务<br>13、提交数据库链接@33457292中的事务也就是事务test15，细节：saveTrueWithTransactionAnnotation创建的事务加入到test15事务中，这部分会commit<br>14、事务test15回滚后，释放数据库连接@33457292</p>
</blockquote>
<p>啰嗦了这么多简单总结一下：<br>required：主方法存在一个事务，子方法的事务传播机制为required，则子方法会合并到主方法的事务里执行,主方法、子方法只要有一个方法异常（默认是RuntimeException或其子类）都会回滚主方法和子方法对数据的修改</p>
<p>requires_new：主方法存在一个事务，子方法的事务传播机制为requires_new，子方法会把主方法的事务挂起，自己新建一个事务，然后自己执行，等自己执行完以后，主方法被挂起的事务才会恢复执行</p>
<p>nested：主方法存在一个事务，子方法的事务传播机制为nested，子方法会建立一个新的事务和savepoint(当前数据状态，主要为了防止子方法中有异常了，能回滚到执行之前)，作为主方法事务的嵌套，子方法的事务不能自己提交，只有主方法的事务提交后子方法才进行提交或回滚。子方法异常，事务一定回滚，如果主方法catch了子方法抛的异常，主方法事务不会回滚，否则主方法事务也回滚。如果子方法没有异常(子事务可以正常提交，但是是否提交还得看主方法事务)，主方法异常了，主方法事务回滚，同时子方法事务可提交的事务也会回滚</p>
<h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p>这个着实有点长了，从入口到整个流程，以及调用链路都标了出来，小佩服自己一下(图片可以放大查看，不失真)<br><img src="/img/SpringTransactionManager/TransactionManager.png" width="100px" height= "400px"/></p>
<h2 id="spring的版本是5-3-23"><a href="#spring的版本是5-3-23" class="headerlink" title="spring的版本是5.3.23"></a>spring的版本是5.3.23</h2><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="SpringApplication-run-SpringTransactionApplication-class-args"><a href="#SpringApplication-run-SpringTransactionApplication-class-args" class="headerlink" title="SpringApplication.run(SpringTransactionApplication.class, args);"></a>SpringApplication.run(SpringTransactionApplication.class, args);</h3><p>对应流程图中的1<br>启动springboot程序，会首先进入到SpringApplication#run方法(3层调用才进入)<br>在这个方法中进行ApplicationContext的创建以及刷新，目的是完成项目所需要spring环境配置和其他依赖配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">   //首先看到这个方法的返回值是ConfigurableApplicationContext 很自然就可以想到这个类直接或间接继承了ApplicationContext然后直接或间接继承了BeanFactory</span><br><span class="line">   //拿到BeanFactory 可以做很多事情，获取bean真的是简简单单了	</span><br><span class="line">   public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">	long startTime = System.nanoTime();</span><br><span class="line">	//创建springboot默认的配置上下文</span><br><span class="line">	DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">	ConfigurableApplicationContext context = null;</span><br><span class="line">	configureHeadlessProperty();</span><br><span class="line">	//通过类加载器创建spring工厂实例并注册启动监听器</span><br><span class="line">	SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">	listeners.starting(bootstrapContext, this.mainApplicationClass);</span><br><span class="line">	try &#123;</span><br><span class="line">	        //处理参数args成CommandLineArgs对象，具体是把参数分为optionArgs和nonOptionArgs来给下边的环境配置使用</span><br><span class="line">		ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">		ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">		configureIgnoreBeanInfo(environment);</span><br><span class="line">		Banner printedBanner = printBanner(environment);</span><br><span class="line">		//创建ConfigurableApplicationContext为单例bean的创建和初始化进行做准备</span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">		context.setApplicationStartup(this.applicationStartup);</span><br><span class="line">		prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">		//这个方法是容器初始化的入口，在方法中调用SpringApplication#refresh方法</span><br><span class="line">		refreshContext(context);</span><br><span class="line">		afterRefresh(context, applicationArguments);</span><br><span class="line">		Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">		if (this.logStartupInfo) &#123;</span><br><span class="line">			new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);</span><br><span class="line">		&#125;</span><br><span class="line">		listeners.started(context, timeTakenToStartup);</span><br><span class="line">		callRunners(context, applicationArguments);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">	return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AbstractApplicationContext-refresh"><a href="#AbstractApplicationContext-refresh" class="headerlink" title="AbstractApplicationContext#refresh"></a>AbstractApplicationContext#refresh</h3><p>对应流程图中的2<br>这个方法在学习生命周期的时候会遇到的第一个方法,这个方法主要做spring容器配置以及bean初始化相关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">    synchronized(this.startupShutdownMonitor) &#123;</span><br><span class="line">        StartupStep contextRefresh = this.applicationStartup.start(&quot;spring.context.refresh&quot;);</span><br><span class="line"> //准备刷新上下文,具体做一些启动日期和活动标志的设置以及执行一些属性资源的初始化</span><br><span class="line">        this.prepareRefresh();</span><br><span class="line"> //创建BeanFactory 具体的逻辑是 如果存在以前的BeanFactory就销毁Bean关闭工厂，重新创建，重新创建完后会调用</span><br><span class="line"> //setSerializationId(getId());customizeBeanFactory(beanFactory);loadBeanDefinitions(beanFactory);这三方法做一些其他配置，这里不细探究</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();</span><br><span class="line"> //配置工厂的标准上下文特征，例如上下文的类加载器和后处理器，后边还有一大堆的set regist 方法都是装备BeanFactory使其功能更完备</span><br><span class="line">        this.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">   //在标准初始化之后修改应用程序上下文的内部 Bean 工厂，所有 Bean 定义都将被加载，但尚未实例化任何 bean。这允许在某些 </span><br><span class="line">//ApplicationContext 实现中注册特殊的 BeanPostProcessor，这个是空方法，留给子类做扩展使用</span><br><span class="line">            this.postProcessBeanFactory(beanFactory);</span><br><span class="line">            StartupStep beanPostProcess = this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;);</span><br><span class="line">//实例化并调用所有注册的 BeanFactoryPostProcessor bean，如果给定，则遵守显式顺序，必须在单一实例化之前调用。</span><br><span class="line">            this.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">//实例化并注册所有 BeanPostProcessor的实现类，如果给定顺序，则遵循显式顺序。必须在应用程序 Bean 的任何实例化之前调用。</span><br><span class="line">            this.registerBeanPostProcessors(beanFactory);</span><br><span class="line">            beanPostProcess.end();</span><br><span class="line">//初始化context的MessageSource，用于消息模块的国际化，有两个实现类ResourceBundleMessageSource\ReloadableResourceBundleMessageSource</span><br><span class="line">            this.initMessageSource();</span><br><span class="line">//初始化应用程序事件多播器。如果上下文中未定义任何内容，则使用 SimpleApplicationEventMulticaster。</span><br><span class="line">            this.initApplicationEventMulticaster();</span><br><span class="line">//子类可以重写用来添加特定于上下文的刷新工作。在实例化单例之前调用特殊 bean 的初始化。</span><br><span class="line">            this.onRefresh();</span><br><span class="line">//添加实现 ApplicationListener 的 bean 作为侦听器。不影响其他侦听器，可以在不成为 bean 的情况下添加这些侦听器。</span><br><span class="line">            this.registerListeners();</span><br><span class="line">//对应流程图中的3</span><br><span class="line">//完成beanFactoryd的初始化工作，实例化剩余的非懒加载的单例bean,spring bean初始化的入口也是核心</span><br><span class="line">            this.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">//完成此上下文的刷新，调用生命周期处理器的 onRefresh（） 方法并发布 ContextRefreshedEvent。</span><br><span class="line">            this.finishRefresh();</span><br><span class="line">        &#125; catch (BeansException var10) &#123;</span><br><span class="line">            if (this.logger.isWarnEnabled()) &#123;</span><br><span class="line">                this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var10);</span><br><span class="line">            &#125;</span><br><span class="line">//销毁单例bean</span><br><span class="line">            this.destroyBeans();</span><br><span class="line">//此context的刷新尝试，在引发异常后重置活动标志。将active置为false</span><br><span class="line">            this.cancelRefresh(var10);</span><br><span class="line">            throw var10;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">   //重置 Spring 的公共的元数据缓存，特别是 ReflectionUtils、AnnotationUtils、ResolvevableType 和 CachedIntrospectionResults 缓存。</span><br><span class="line">            this.resetCommonCaches();</span><br><span class="line">//记录步骤的状态以及可能的其他指标，如执行时间。结束后，不允许更改步骤状态。</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AbstractAutoProxyCreator-wrapIfNecessary"><a href="#AbstractAutoProxyCreator-wrapIfNecessary" class="headerlink" title="AbstractAutoProxyCreator#wrapIfNecessary"></a>AbstractAutoProxyCreator#wrapIfNecessary</h3><p>对应流程图中的13<br>这个方法就是创建代理对象或者返回原始的bean对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class="line">	if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line">	// 判断这个bean不需要代理，如果不需要代理直接返回原始bean</span><br><span class="line">	if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line">	if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">		this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Create proxy if we have advice.</span><br><span class="line">	// 获取service所有的切面</span><br><span class="line">	Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</span><br><span class="line">	if (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">		// 走到这里说明需要代理，通过advisedBeans来记录bean 需要创建代理</span><br><span class="line">		this.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">		// 创建代理</span><br><span class="line">		Object proxy = createProxy(</span><br><span class="line">				bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class="line">		this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">		// 返回代理对象</span><br><span class="line">		return proxy;</span><br><span class="line">	&#125;</span><br><span class="line">	//走到这里，说明没有进if分支，没有创建代理，通过advisedBeans记录bean不需要代理</span><br><span class="line">	this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">	//返回原始的bean</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单总结：判断bean是否需要代理，不需要返回原始bean，需要就创建代理，返回代理对象</p>
<h4 id="AbstractAdvisorAutoProxyCreator-getAdvicesAndAdvisorsForBean"><a href="#AbstractAdvisorAutoProxyCreator-getAdvicesAndAdvisorsForBean" class="headerlink" title="AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean"></a>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</h4><p>对应流程图中的14、15 接口方法被实现类重写<br>获取bean的切面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">		Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) &#123;</span><br><span class="line">	//获取bean的切面  进入具体的子方法  对应流程图中的16</span><br><span class="line">	List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">	//如果切面方法为空，返回null，这个bean不需要代理</span><br><span class="line">	if (advisors.isEmpty()) &#123;</span><br><span class="line">		return DO_NOT_PROXY;</span><br><span class="line">	&#125;</span><br><span class="line">	return advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractAdvisorAutoProxyCreator-findEligibleAdvisors"><a href="#AbstractAdvisorAutoProxyCreator-findEligibleAdvisors" class="headerlink" title="AbstractAdvisorAutoProxyCreator#findEligibleAdvisors"></a>AbstractAdvisorAutoProxyCreator#findEligibleAdvisors</h4><p>对应流程图中的16<br>获取bean所有匹配的切面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line">	//找到所有的切面</span><br><span class="line">	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">	//从切面中找到和beanClass匹配的切面bean,也就是transactionService的切面bean 对应流程图中的22</span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">	extendAdvisors(eligibleAdvisors);</span><br><span class="line">	if (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">		eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">	&#125;</span><br><span class="line">	return eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AnnotationAwareAspectJAutoProxyCreator-findCandidateAdvisors"><a href="#AnnotationAwareAspectJAutoProxyCreator-findCandidateAdvisors" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors"></a>AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors</h4><p>对应流程图中的17、18</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;Advisor&gt; findCandidateAdvisors() &#123;</span><br><span class="line">	// 调用父类方法寻找符合的切面  对应流程图中的19</span><br><span class="line">	List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();</span><br><span class="line">	// Build Advisors for all AspectJ aspects in the bean factory.</span><br><span class="line">	if (this.aspectJAdvisorsBuilder != null) &#123;</span><br><span class="line">		advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">	&#125;</span><br><span class="line">	return advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractAdvisorAutoProxyCreator-findCandidateAdvisors"><a href="#AbstractAdvisorAutoProxyCreator-findCandidateAdvisors" class="headerlink" title="AbstractAdvisorAutoProxyCreator#findCandidateAdvisors"></a>AbstractAdvisorAutoProxyCreator#findCandidateAdvisors</h4><p>对应流程图中的19</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;Advisor&gt; findCandidateAdvisors() &#123;</span><br><span class="line">	Assert.state(this.advisorRetrievalHelper != null, &quot;No BeanFactoryAdvisorRetrievalHelper available&quot;);</span><br><span class="line">	// 查找bean的切面  对应流程图中的20</span><br><span class="line">	return this.advisorRetrievalHelper.findAdvisorBeans();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BeanFactoryAdvisorRetrievalHelper-findAdvisorBeans"><a href="#BeanFactoryAdvisorRetrievalHelper-findAdvisorBeans" class="headerlink" title="BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans"></a>BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans</h4><p>对应流程图中的20</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Advisor&gt; findAdvisorBeans() &#123;</span><br><span class="line">	// 从缓存中获取切面名称</span><br><span class="line">	String[] advisorNames = this.cachedAdvisorBeanNames;</span><br><span class="line">	if (advisorNames == null) &#123;</span><br><span class="line">		// 获取所有含有切面类型的bean名称</span><br><span class="line">		advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">				this.beanFactory, Advisor.class, true, false);</span><br><span class="line">		this.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">	&#125;</span><br><span class="line">	if (advisorNames.length == 0) &#123;</span><br><span class="line">		return new ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	//定义切面列表</span><br><span class="line">	List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();</span><br><span class="line">	//遍历含有切面的bean</span><br><span class="line">	for (String name : advisorNames) &#123;</span><br><span class="line">		if (isEligibleBean(name)) &#123;</span><br><span class="line">			if (this.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line">				if (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(&quot;Skipping currently created advisor &#x27;&quot; + name + &quot;&#x27;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					//创建切面类型的bean(getBean方法没有获取到就创建)，加入到切面列表中</span><br><span class="line">					advisors.add(this.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">				&#125;</span><br><span class="line">				catch (BeanCreationException ex) &#123;</span><br><span class="line">					Throwable rootCause = ex.getMostSpecificCause();</span><br><span class="line">					if (rootCause instanceof BeanCurrentlyInCreationException) &#123;</span><br><span class="line">						BeanCreationException bce = (BeanCreationException) rootCause;</span><br><span class="line">						String bceBeanName = bce.getBeanName();</span><br><span class="line">						if (bceBeanName != null &amp;&amp; this.beanFactory.isCurrentlyInCreation(bceBeanName)) &#123;</span><br><span class="line">							if (logger.isTraceEnabled()) &#123;</span><br><span class="line">								logger.trace(&quot;Skipping advisor &#x27;&quot; + name +</span><br><span class="line">										&quot;&#x27; with dependency on currently created bean: &quot; + ex.getMessage());</span><br><span class="line">							&#125;</span><br><span class="line">							// Ignore: indicates a reference back to the bean we&#x27;re trying to advise.</span><br><span class="line">							// We want to find advisors other than the currently created bean itself.</span><br><span class="line">							continue;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					throw ex;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return advisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>获取完切面之后回到AbstractAdvisorAutoProxyCreator#findEligibleAdvisors方法，接着往下走</p>
<h4 id="AbstractAdvisorAutoProxyCreator-findAdvisorsThatCanApply"><a href="#AbstractAdvisorAutoProxyCreator-findAdvisorsThatCanApply" class="headerlink" title="AbstractAdvisorAutoProxyCreator#findAdvisorsThatCanApply"></a>AbstractAdvisorAutoProxyCreator#findAdvisorsThatCanApply</h4><p>对应流程图中的22</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;Advisor&gt; findAdvisorsThatCanApply(</span><br><span class="line">		List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line"></span><br><span class="line">	ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">	try &#123;</span><br><span class="line">		//找到匹配beanClass的切面bean</span><br><span class="line">		return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		ProxyCreationContext.setCurrentProxiedBeanName(null);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AopUtils-findAdvisorsThatCanApply"><a href="#AopUtils-findAdvisorsThatCanApply" class="headerlink" title="AopUtils#findAdvisorsThatCanApply"></a>AopUtils#findAdvisorsThatCanApply</h4><p>对应流程图中的23</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) &#123;</span><br><span class="line">	if (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">		return candidateAdvisors;</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;();</span><br><span class="line">	for (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">		if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">			eligibleAdvisors.add(candidate);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	boolean hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">	for (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">		if (candidate instanceof IntroductionAdvisor) &#123;</span><br><span class="line">			// already processed</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		//判断给定的切面bean中是否匹配目标class,也就是TransactionService.class</span><br><span class="line">		if (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">			eligibleAdvisors.add(candidate);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AopUtils-canApply-Advisor-advisor-Class-lt-gt-targetClass-boolean-hasIntroductions"><a href="#AopUtils-canApply-Advisor-advisor-Class-lt-gt-targetClass-boolean-hasIntroductions" class="headerlink" title="AopUtils#canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions)"></a>AopUtils#canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions)</h4><p>对应流程图中的24</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123;</span><br><span class="line">	if (advisor instanceof IntroductionAdvisor) &#123;</span><br><span class="line">		return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">		//强转为PointcutAdvisor</span><br><span class="line">		PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class="line">		//判断给定的切点能否完全适用于给定的类  对应流程图中的25</span><br><span class="line">		return canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// It doesn&#x27;t have a pointcut so we assume it applies.</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AopUtils-canApply-Pointcut-pc-Class-lt-gt-targetClass-boolean-hasIntroductions"><a href="#AopUtils-canApply-Pointcut-pc-Class-lt-gt-targetClass-boolean-hasIntroductions" class="headerlink" title="AopUtils#canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions)"></a>AopUtils#canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions)</h4><p>对应流程图中的25<br>判断给定的切点能否完全适用于给定的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123;</span><br><span class="line">	Assert.notNull(pc, &quot;Pointcut must not be null&quot;);</span><br><span class="line">	if (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取切点匹配的切面 得到的是com.xc.springtransaction.service.TransactionService</span><br><span class="line">	MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">	if (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">		// No need to iterate the methods if we&#x27;re matching any method anyway...</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;</span><br><span class="line">	if (methodMatcher instanceof IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">		introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;&gt;();</span><br><span class="line">	//判断targetClass是不是由方法getProxyClass或newProxyInstance生成的，即是不是cglib代理或者jdk代理生成的 </span><br><span class="line">	if (!Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">		//把自己(com.xc.springtransaction.service.TransactionService)添加到classes</span><br><span class="line">		classes.add(ClassUtils.getUserClass(targetClass));</span><br><span class="line">	&#125;</span><br><span class="line">	//获取targetClass实现所有接口</span><br><span class="line">	classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"></span><br><span class="line">	for (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">		//获取类中声明的所有方法</span><br><span class="line">		Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">		for (Method method : methods) &#123;</span><br><span class="line">			if (introductionAwareMethodMatcher != null ?</span><br><span class="line">					introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">					//判断targetClass的方法上 是否有事务注解可以获取到事务源参数 对应流程图中的26、27</span><br><span class="line">					methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TransactionAttributeSourcePointcut-matches"><a href="#TransactionAttributeSourcePointcut-matches" class="headerlink" title="TransactionAttributeSourcePointcut#matches"></a>TransactionAttributeSourcePointcut#matches</h4><p>对应流程图中的27<br>获取事务属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">	//获取事务属性源 </span><br><span class="line">	TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">	//获取事务属性  对应流程图中的28、29</span><br><span class="line">	return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractFallbackTransactionAttributeSource-getTransactionAttribute"><a href="#AbstractFallbackTransactionAttributeSource-getTransactionAttribute" class="headerlink" title="AbstractFallbackTransactionAttributeSource#getTransactionAttribute"></a>AbstractFallbackTransactionAttributeSource#getTransactionAttribute</h4><p>对应流程图中的29<br>获取调用方法的事务属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">	if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	// 先检查缓存中有没有事务属性</span><br><span class="line">	Object cacheKey = getCacheKey(method, targetClass);</span><br><span class="line">	TransactionAttribute cached = this.attributeCache.get(cacheKey);</span><br><span class="line">	if (cached != null) &#123;			</span><br><span class="line">		if (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return cached;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// 走到这里说明缓存中没有事务属性，需要获取一下事务属性 对应流程图中的30</span><br><span class="line">		TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</span><br><span class="line">		// Put it in the cache.</span><br><span class="line">		if (txAttr == null) &#123;</span><br><span class="line">			//获取到事务属性信息后放入缓存</span><br><span class="line">			this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);</span><br><span class="line">			if (txAttr instanceof DefaultTransactionAttribute) &#123;</span><br><span class="line">				DefaultTransactionAttribute dta = (DefaultTransactionAttribute) txAttr;</span><br><span class="line">				dta.setDescriptor(methodIdentification);</span><br><span class="line">				dta.resolveAttributeStrings(this.embeddedValueResolver);</span><br><span class="line">			&#125;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;Adding transactional method &#x27;&quot; + methodIdentification + &quot;&#x27; with attribute: &quot; + txAttr);</span><br><span class="line">			&#125;</span><br><span class="line">			this.attributeCache.put(cacheKey, txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		return txAttr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractFallbackTransactionAttributeSource-computeTransactionAttribute"><a href="#AbstractFallbackTransactionAttributeSource-computeTransactionAttribute" class="headerlink" title="AbstractFallbackTransactionAttributeSource#computeTransactionAttribute"></a>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</h4><p>对应流程图中的30<br>获取事务属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">	// 校验方法声明的访问权限是不是public的  同时也说明了事务起作用的前提是方法修饰符必须是public的</span><br><span class="line">	if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	// 获取具体的方法</span><br><span class="line">	Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line">	//第一次先尝试获取方法的事务属性(@Transactional标记在方法上)，能获取到就直接返回了</span><br><span class="line">	//对应流程图中的31</span><br><span class="line">	TransactionAttribute txAttr = findTransactionAttribute(specificMethod);</span><br><span class="line">	if (txAttr != null) &#123;</span><br><span class="line">		return txAttr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//第二次尝试获取类上的事务属性(@Transactional注解是标记在类上)</span><br><span class="line">	txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line">	if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">		return txAttr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (specificMethod != method) &#123;</span><br><span class="line">		// Fallback is to look at the original method.</span><br><span class="line">		txAttr = findTransactionAttribute(method);</span><br><span class="line">		if (txAttr != null) &#123;</span><br><span class="line">			return txAttr;</span><br><span class="line">		&#125;</span><br><span class="line">		// Last fallback is the class of the original method.</span><br><span class="line">		txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line">		if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">			return txAttr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AnnotationTransactionAttributeSource-findTransactionAttribute"><a href="#AnnotationTransactionAttributeSource-findTransactionAttribute" class="headerlink" title="AnnotationTransactionAttributeSource#findTransactionAttribute"></a>AnnotationTransactionAttributeSource#findTransactionAttribute</h4><p>对应流程图中的31<br>获取事务属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected TransactionAttribute findTransactionAttribute(Method method) &#123;</span><br><span class="line">	return determineTransactionAttribute(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AnnotationTransactionAttributeSource-determineTransactionAttribute"><a href="#AnnotationTransactionAttributeSource-determineTransactionAttribute" class="headerlink" title="AnnotationTransactionAttributeSource#determineTransactionAttribute"></a>AnnotationTransactionAttributeSource#determineTransactionAttribute</h4><p>对应流程图中的32<br>获取事务属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected TransactionAttribute determineTransactionAttribute(AnnotatedElement element) &#123;</span><br><span class="line">	for (TransactionAnnotationParser parser : this.annotationParsers) &#123;</span><br><span class="line">		//解析事务注解标记的事务属性信息 对应流程图中的33、34</span><br><span class="line">		TransactionAttribute attr = parser.parseTransactionAnnotation(element);</span><br><span class="line">		if (attr != null) &#123;</span><br><span class="line">			return attr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SpringTransactionAnnotationParser-parseTransactionAnnotation"><a href="#SpringTransactionAnnotationParser-parseTransactionAnnotation" class="headerlink" title="SpringTransactionAnnotationParser#parseTransactionAnnotation"></a>SpringTransactionAnnotationParser#parseTransactionAnnotation</h4><p>对应流程图中的34<br>解析事务注解标记的事务属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public TransactionAttribute parseTransactionAnnotation(AnnotatedElement element) &#123;</span><br><span class="line">	//从方法的注解中获取事务属性</span><br><span class="line">	AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(</span><br><span class="line">			element, Transactional.class, false, false);</span><br><span class="line">	if (attributes != null) &#123;</span><br><span class="line">		//解析事务属性 对应流程图中的35</span><br><span class="line">		return parseTransactionAnnotation(attributes);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SpringTransactionAnnotationParser-parseTransactionAnnotation-AnnotationAttributes-attributes"><a href="#SpringTransactionAnnotationParser-parseTransactionAnnotation-AnnotationAttributes-attributes" class="headerlink" title="SpringTransactionAnnotationParser#parseTransactionAnnotation(AnnotationAttributes attributes)"></a>SpringTransactionAnnotationParser#parseTransactionAnnotation(AnnotationAttributes attributes)</h4><p>对应流程图中的35<br>解析事务属性，封装规则事务属性对象返回，没啥好说的一堆set方法 设置什么传播行为啊 隔离级别啊 针对哪些异常触发回滚啊···</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">protected TransactionAttribute parseTransactionAnnotation(AnnotationAttributes attributes) &#123;</span><br><span class="line">	RuleBasedTransactionAttribute rbta = new RuleBasedTransactionAttribute();</span><br><span class="line"></span><br><span class="line">	Propagation propagation = attributes.getEnum(&quot;propagation&quot;);</span><br><span class="line">	rbta.setPropagationBehavior(propagation.value());</span><br><span class="line">	Isolation isolation = attributes.getEnum(&quot;isolation&quot;);</span><br><span class="line">	rbta.setIsolationLevel(isolation.value());</span><br><span class="line"></span><br><span class="line">	rbta.setTimeout(attributes.getNumber(&quot;timeout&quot;).intValue());</span><br><span class="line">	String timeoutString = attributes.getString(&quot;timeoutString&quot;);</span><br><span class="line">	Assert.isTrue(!StringUtils.hasText(timeoutString) || rbta.getTimeout() &lt; 0,</span><br><span class="line">			&quot;Specify &#x27;timeout&#x27; or &#x27;timeoutString&#x27;, not both&quot;);</span><br><span class="line">	rbta.setTimeoutString(timeoutString);</span><br><span class="line"></span><br><span class="line">	rbta.setReadOnly(attributes.getBoolean(&quot;readOnly&quot;));</span><br><span class="line">	rbta.setQualifier(attributes.getString(&quot;value&quot;));</span><br><span class="line">	rbta.setLabels(Arrays.asList(attributes.getStringArray(&quot;label&quot;)));</span><br><span class="line"></span><br><span class="line">	List&lt;RollbackRuleAttribute&gt; rollbackRules = new ArrayList&lt;&gt;();</span><br><span class="line">	for (Class&lt;?&gt; rbRule : attributes.getClassArray(&quot;rollbackFor&quot;)) &#123;</span><br><span class="line">		rollbackRules.add(new RollbackRuleAttribute(rbRule));</span><br><span class="line">	&#125;</span><br><span class="line">	for (String rbRule : attributes.getStringArray(&quot;rollbackForClassName&quot;)) &#123;</span><br><span class="line">		rollbackRules.add(new RollbackRuleAttribute(rbRule));</span><br><span class="line">	&#125;</span><br><span class="line">	for (Class&lt;?&gt; rbRule : attributes.getClassArray(&quot;noRollbackFor&quot;)) &#123;</span><br><span class="line">		rollbackRules.add(new NoRollbackRuleAttribute(rbRule));</span><br><span class="line">	&#125;</span><br><span class="line">	for (String rbRule : attributes.getStringArray(&quot;noRollbackForClassName&quot;)) &#123;</span><br><span class="line">		rollbackRules.add(new NoRollbackRuleAttribute(rbRule));</span><br><span class="line">	&#125;</span><br><span class="line">	rbta.setRollbackRules(rollbackRules);</span><br><span class="line"></span><br><span class="line">	return rbta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一步步返回，回到AbstractFallbackTransactionAttributeSource#getTransactionAttribute方法继续走，对应流程图中的36</p>
<h4 id="AbstractFallbackTransactionAttributeSource-getTransactionAttribute-1"><a href="#AbstractFallbackTransactionAttributeSource-getTransactionAttribute-1" class="headerlink" title="AbstractFallbackTransactionAttributeSource#getTransactionAttribute"></a>AbstractFallbackTransactionAttributeSource#getTransactionAttribute</h4><p>对应流程图中的29</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">	if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	// 先检查缓存中有没有事务属性</span><br><span class="line">	Object cacheKey = getCacheKey(method, targetClass);</span><br><span class="line">	TransactionAttribute cached = this.attributeCache.get(cacheKey);</span><br><span class="line">	if (cached != null) &#123;			</span><br><span class="line">		if (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return cached;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// 走到这里说明缓存中没有事务属性，需要获取一下事务属性 对应流程图中的30</span><br><span class="line">		// 走了那么长的调用链路，终于走回到这里了 good fuck to me！！！  现在是北京时间0:34  一点困意都没有 哈欠不断 我还能敲</span><br><span class="line">		TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</span><br><span class="line">		// Put it in the cache.</span><br><span class="line">		if (txAttr == null) &#123;</span><br><span class="line">			//获取到事务属性信息后放入缓存</span><br><span class="line">			this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);</span><br><span class="line">			if (txAttr instanceof DefaultTransactionAttribute) &#123;</span><br><span class="line">				DefaultTransactionAttribute dta = (DefaultTransactionAttribute) txAttr;</span><br><span class="line">				dta.setDescriptor(methodIdentification);</span><br><span class="line">				dta.resolveAttributeStrings(this.embeddedValueResolver);</span><br><span class="line">			&#125;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;Adding transactional method &#x27;&quot; + methodIdentification + &quot;&#x27; with attribute: &quot; + txAttr);</span><br><span class="line">			&#125;</span><br><span class="line">			//缓存事务属性</span><br><span class="line">			this.attributeCache.put(cacheKey, txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		return txAttr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回到AbstractAutoProxyCreator#wrapIfNecessary方法，获取到bean的切面列表后创建代理对象 对应流程图中的37<br>对应流程图中的13<br>这个方法就是创建代理对象或者返回原始的bean对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class="line">	if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line">	// 判断这个bean不需要代理，如果不需要代理直接返回原始bean</span><br><span class="line">	if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line">	if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">		this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Create proxy if we have advice.</span><br><span class="line">	// 获取service所有的切面  真不容易啊 走了那么长的调用链路终于回来了</span><br><span class="line">	Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</span><br><span class="line">	if (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">		// 走到这里说明需要代理，通过advisedBeans来记录bean 需要创建代理</span><br><span class="line">		this.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">		// 创建代理 重头戏来了  敲完这个方法  我去见周公了！！！</span><br><span class="line">		// 创建代理具体分析 在文章SpringAop中，这里不在赘述</span><br><span class="line">		Object proxy = createProxy(</span><br><span class="line">				bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class="line">		this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">		// 返回代理对象</span><br><span class="line">		return proxy;</span><br><span class="line">	&#125;</span><br><span class="line">	//走到这里，说明没有进if分支，没有创建代理，通过advisedBeans记录bean不需要代理</span><br><span class="line">	this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">	//返回原始的bean</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单总结：先获取service所有的切面方法，如果匹配到事务注解，就解析注解获取事务属性封装TransactionAttribute，然后放到attributeCache,针对切面方法创建aop代理(jdk或者cglib)</p>
<h3 id="创建aop代理"><a href="#创建aop代理" class="headerlink" title="创建aop代理"></a>创建aop代理</h3><p>创建aop代理部分，可以查看文章SpringAop这里不做多余的解释，他只是我的妹妹，妹妹的姿色很有韵味~~~~  啊呸，妹妹说紫色很有韵味~~~</p>
<h3 id="下面是事务执行过程介绍"><a href="#下面是事务执行过程介绍" class="headerlink" title="下面是事务执行过程介绍"></a>下面是事务执行过程介绍</h3><p>创建完aop代理对象以后，就开始执行真正的业务方法，在这之前，会先进入拦截器</p>
<h4 id="CglibAopProxy-DynamicAdvisedInterceptor-intercept"><a href="#CglibAopProxy-DynamicAdvisedInterceptor-intercept" class="headerlink" title="CglibAopProxy.DynamicAdvisedInterceptor#intercept"></a>CglibAopProxy.DynamicAdvisedInterceptor#intercept</h4><p>对应流程图中的38、39</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">	Object oldProxy = null;</span><br><span class="line">	boolean setProxyContext = false;</span><br><span class="line">	Object target = null;</span><br><span class="line">	TargetSource targetSource = this.advised.getTargetSource();</span><br><span class="line">	try &#123;</span><br><span class="line">		if (this.advised.exposeProxy) &#123;				</span><br><span class="line">			//使当前给定的代理可用，获取旧值(之前的代理)</span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = true;</span><br><span class="line">		&#125;</span><br><span class="line">		// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span><br><span class="line">		target = targetSource.getTarget();</span><br><span class="line">		Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);</span><br><span class="line">		//根据配置获取给定方法的 org.aopalliance.intercept.MethodInterceptor对象列表，也就是这个方法需要经过的拦截器。</span><br><span class="line">		//一般这个拦截器链中就一个对象 TransactionInterceptor事务拦截器</span><br><span class="line">		List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">		Object retVal;			</span><br><span class="line">		if (chain.isEmpty() &amp;&amp; CglibMethodInvocation.isMethodProxyCompatible(method)) &#123;			</span><br><span class="line">			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">			retVal = invokeMethod(target, method, argsToUse, methodProxy);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// 创建cglib方法调用进行处理 对应流程图中的40  特别注意这里的有构造方法CglibMethodInvocation中传递了chain</span><br><span class="line">			retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">		&#125;</span><br><span class="line">		retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">		return retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">			targetSource.releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line">		if (setProxyContext) &#123;</span><br><span class="line">			// Restore old proxy.</span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CglibAopProxy-CglibMethodInvocation"><a href="#CglibAopProxy-CglibMethodInvocation" class="headerlink" title="CglibAopProxy.CglibMethodInvocation"></a>CglibAopProxy.CglibMethodInvocation</h4><p>对应流程图中的40</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		//调用父类的处理方法 对应流程图中的41</span><br><span class="line">		return super.proceed();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (RuntimeException ex) &#123;</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123;</span><br><span class="line">		if (ReflectionUtils.declaresException(getMethod(), ex.getClass()) ||</span><br><span class="line">				KotlinDetector.isKotlinType(getMethod().getDeclaringClass())) &#123;				</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;				</span><br><span class="line">			throw new UndeclaredThrowableException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReflectiveMethodInvocation-proceed"><a href="#ReflectiveMethodInvocation-proceed" class="headerlink" title="ReflectiveMethodInvocation#proceed"></a>ReflectiveMethodInvocation#proceed</h4><p>对应流程图中的41</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">	// 当前拦截器索引从-1开始递增+1  流程图中的39中已经获取了拦截器链chain(他的size是1 TransactonInterceptor)</span><br><span class="line">	// 通过CglibMethodInvocation构造传递了chain,调用父类有参构造方法ReflectiveMethodInvocation最后把chain赋值</span><br><span class="line">	// 给了interceptorsAndDynamicMethodMatchers  所以这里-1 == 1-1  不成立</span><br><span class="line">	if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">		return invokeJoinpoint();</span><br><span class="line">	&#125;</span><br><span class="line">	// 从拦截器链中获取拦截器  interceptorsAndDynamicMethodMatchers中就一个TransactionInterceptor,</span><br><span class="line">	// 先+1 再取值 类似list.get(0) 获取拦截器链中的对象即TransactionInterceptor</span><br><span class="line">	Object interceptorOrInterceptionAdvice =</span><br><span class="line">			this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line">	// 	TransactionInterceptor 跟 InterceptorAndDynamicMethodMatcher不存在直接或间接的继承关系，后者是独立的类 这里不成立</span><br><span class="line">	if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;			</span><br><span class="line">		InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">				(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">		Class&lt;?&gt; targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());</span><br><span class="line">		if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) &#123;</span><br><span class="line">			return dm.interceptor.invoke(this);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;				</span><br><span class="line">			return proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;			</span><br><span class="line">		// 把TransactionInterceptor 强转为 MethodInterceptor后调用invoke方法 对应流程图中的42</span><br><span class="line">		return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TransactionInterceptor-invoke"><a href="#TransactionInterceptor-invoke" class="headerlink" title="TransactionInterceptor#invoke"></a>TransactionInterceptor#invoke</h4><p>对应流程图中的42</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">	// 获取被代理的类信息</span><br><span class="line">	Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);</span><br><span class="line"></span><br><span class="line">	// 执行事务  核心方法 对应流程图的43</span><br><span class="line">	return invokeWithinTransaction(invocation.getMethod(), targetClass, new CoroutinesInvocationCallback() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		@Nullable</span><br><span class="line">		public Object proceedWithInvocation() throws Throwable &#123;</span><br><span class="line">			return invocation.proceed();</span><br><span class="line">		&#125;</span><br><span class="line">		@Override</span><br><span class="line">		public Object getTarget() &#123;</span><br><span class="line">			return invocation.getThis();</span><br><span class="line">		&#125;</span><br><span class="line">		@Override</span><br><span class="line">		public Object[] getArguments() &#123;</span><br><span class="line">			return invocation.getArguments();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TransactionAspectSupport-invokeWithinTransaction"><a href="#TransactionAspectSupport-invokeWithinTransaction" class="headerlink" title="TransactionAspectSupport#invokeWithinTransaction"></a>TransactionAspectSupport#invokeWithinTransaction</h4><p>对应流程图中的43<br>执行事务  核心方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,</span><br><span class="line">		final InvocationCallback invocation) throws Throwable &#123;</span><br><span class="line">	//获取事务属性源</span><br><span class="line">	TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">	//获取事务属性 对应流程图中的44</span><br><span class="line">	final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);</span><br><span class="line">	//获取事务管理器 一般是JdbcTransactionManager</span><br><span class="line">	final TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">	// JdbcTransactionManager 和 ReactiveTransactionManager 八竿子打不着 if分支不走，代码省略</span><br><span class="line">	if (this.reactiveAdapterRegistry != null &amp;&amp; tm instanceof ReactiveTransactionManager) &#123;</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">	// 获取配置的事务管理器</span><br><span class="line">	PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line">	// 获取被@Transactional注解标注的方法标识符</span><br><span class="line">	final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line">	// txAttr不为空  ptm是JdbcTransactionManager 和 CallbackPreferringPlatformTransactionManager 没有关系 进入if分支</span><br><span class="line">	if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">		// 如有必要通过给定的事务属性参数创建声明式的事务信息，对应流程图45</span><br><span class="line">		// 可以推出该if分支是处理声明式的事务 则另一个else分支就是处理编程式的事务啦</span><br><span class="line">		TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line">		try &#123;</span><br><span class="line">			//真正的业务方法回调</span><br><span class="line">			retVal = invocation.proceedWithInvocation();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			// target invocation exception</span><br><span class="line">			completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			cleanupTransactionInfo(txInfo);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (retVal != null &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">			// Set rollback-only in case of Vavr failure matching our rollback rules...</span><br><span class="line">			TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line">			if (status != null &amp;&amp; txAttr != null) &#123;</span><br><span class="line">				retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		commitTransactionAfterReturning(txInfo);</span><br><span class="line">		return retVal;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123;</span><br><span class="line">		Object result;</span><br><span class="line">		final ThrowableHolder throwableHolder = new ThrowableHolder();</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractFallbackTransactionAttributeSource-getTransactionAttribute-2"><a href="#AbstractFallbackTransactionAttributeSource-getTransactionAttribute-2" class="headerlink" title="AbstractFallbackTransactionAttributeSource#getTransactionAttribute"></a>AbstractFallbackTransactionAttributeSource#getTransactionAttribute</h4><p>对应流程图中的44<br>其实这个方法已经在上边分析过了 对应流程图29</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">	if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	// 先检查缓存中有没有事务属性</span><br><span class="line">	Object cacheKey = getCacheKey(method, targetClass);</span><br><span class="line">	////之前步骤 从流程图14获取切面列表 到 流程图36 已经获取到事务属性信息放到缓存中了 </span><br><span class="line">	////所以在invokeWithinTransaction方法调用getTransactionAttribute的时候，可以直接从缓存中取</span><br><span class="line">	TransactionAttribute cached = this.attributeCache.get(cacheKey);</span><br><span class="line">	if (cached != null) &#123;			</span><br><span class="line">		if (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">		    //// 返回到invokeWithinTransaction方法</span><br><span class="line">			return cached;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// 走到这里说明缓存中没有事务属性，需要获取一下事务属性 对应流程图中的30</span><br><span class="line">		TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</span><br><span class="line">		// Put it in the cache.</span><br><span class="line">		if (txAttr == null) &#123;</span><br><span class="line">			//获取到事务属性信息后放入缓存</span><br><span class="line">			this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);</span><br><span class="line">			if (txAttr instanceof DefaultTransactionAttribute) &#123;</span><br><span class="line">				DefaultTransactionAttribute dta = (DefaultTransactionAttribute) txAttr;</span><br><span class="line">				dta.setDescriptor(methodIdentification);</span><br><span class="line">				dta.resolveAttributeStrings(this.embeddedValueResolver);</span><br><span class="line">			&#125;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;Adding transactional method &#x27;&quot; + methodIdentification + &quot;&#x27; with attribute: &quot; + txAttr);</span><br><span class="line">			&#125;</span><br><span class="line">			this.attributeCache.put(cacheKey, txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		return txAttr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TransactionAspectSupport-createTransactionIfNecessary"><a href="#TransactionAspectSupport-createTransactionIfNecessary" class="headerlink" title="TransactionAspectSupport#createTransactionIfNecessary"></a>TransactionAspectSupport#createTransactionIfNecessary</h4><p>对应流程图45<br>如果必要的话创建事务信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,</span><br><span class="line">		@Nullable TransactionAttribute txAttr, final String joinpointIdentification) &#123;</span><br><span class="line"></span><br><span class="line">	// If no name specified, apply method identification as transaction name.</span><br><span class="line">	if (txAttr != null &amp;&amp; txAttr.getName() == null) &#123;</span><br><span class="line">		//使用给定的事务属性txAttr创建声明式的事务属性(方法使用注解开启的事务就是声明式的)</span><br><span class="line">		txAttr = new DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public String getName() &#123;</span><br><span class="line">				return joinpointIdentification;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TransactionStatus status = null;</span><br><span class="line">	if (txAttr != null) &#123;</span><br><span class="line">		if (tm != null) &#123;</span><br><span class="line">			//获取事务的状态  对应流程图46</span><br><span class="line">			status = tm.getTransaction(txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Skipping transactional joinpoint [&quot; + joinpointIdentification +</span><br><span class="line">						&quot;] because no transaction manager has been configured&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 封装事务信息返回</span><br><span class="line">	return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractPlatformTransactionManager-getTransaction"><a href="#AbstractPlatformTransactionManager-getTransaction" class="headerlink" title="AbstractPlatformTransactionManager#getTransaction"></a>AbstractPlatformTransactionManager#getTransaction</h4><p>对应流程图46<br>获取事务的状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition)</span><br><span class="line">		throws TransactionException &#123;</span><br><span class="line">	//参数传进来的definition为空则使用默认的事务属性定义</span><br><span class="line">	TransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults());</span><br><span class="line">	//获取事务	对应流程图47</span><br><span class="line">	Object transaction = doGetTransaction();</span><br><span class="line">	boolean debugEnabled = logger.isDebugEnabled();</span><br><span class="line">	if (isExistingTransaction(transaction)) &#123;</span><br><span class="line">		//如若事务存在，查看事务传播行为确定后续操作，比如说加入事务或者当前事务挂起新建事务</span><br><span class="line">		return handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">	&#125;</span><br><span class="line">	// 检查事务定义的超时时间是不是非法的</span><br><span class="line">	if (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">		throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, def.getTimeout());</span><br><span class="line">	&#125;</span><br><span class="line">	//如若没有当前事务，还被标记为PROPAGATION_MANDATORY 就抛异常</span><br><span class="line">	if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">		throw new IllegalTransactionStateException(</span><br><span class="line">				&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">			def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">			def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		SuspendedResourcesHolder suspendedResources = suspend(null);</span><br><span class="line">		if (debugEnabled) &#123;</span><br><span class="line">			logger.debug(&quot;Creating new transaction with name [&quot; + def.getName() + &quot;]: &quot; + def);</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			//开始事务 对应流程图48</span><br><span class="line">			return startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException | Error ex) &#123;</span><br><span class="line">			resume(null, suspendedResources);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span><br><span class="line">		if (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">			logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +</span><br><span class="line">					&quot;isolation level will effectively be ignored: &quot; + def);</span><br><span class="line">		&#125;</span><br><span class="line">		boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		return prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DataSourceTransactionManager-doGetTransaction"><a href="#DataSourceTransactionManager-doGetTransaction" class="headerlink" title="DataSourceTransactionManager#doGetTransaction"></a>DataSourceTransactionManager#doGetTransaction</h4><p>对应流程图47<br>获取事务对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected Object doGetTransaction() &#123;</span><br><span class="line">	//创建数据源事务对象</span><br><span class="line">	DataSourceTransactionObject txObject = new DataSourceTransactionObject();</span><br><span class="line">	//设置事务保存点 事务管理器初始化的时候会把isNestedTransactionAllowed()的值改为true</span><br><span class="line">	txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line">	//通过事务同步管理器获取当前线程的数据库链接，第一次进来事务同步管理器还没有缓存,获取到的是null</span><br><span class="line">	ConnectionHolder conHolder =</span><br><span class="line">			(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());</span><br><span class="line">	txObject.setConnectionHolder(conHolder, false);</span><br><span class="line">	return txObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractPlatformTransactionManager-startTransaction"><a href="#AbstractPlatformTransactionManager-startTransaction" class="headerlink" title="AbstractPlatformTransactionManager#startTransaction"></a>AbstractPlatformTransactionManager#startTransaction</h4><p>对应流程图48<br>开始事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private TransactionStatus startTransaction(TransactionDefinition definition, Object transaction,</span><br><span class="line">		boolean debugEnabled, @Nullable SuspendedResourcesHolder suspendedResources) &#123;</span><br><span class="line"></span><br><span class="line">	boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">	DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">			definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">	//开启事务  对应流程图49		</span><br><span class="line">	doBegin(transaction, definition);</span><br><span class="line">	prepareSynchronization(status, definition);</span><br><span class="line">	return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DataSourceTransactionManager-doBegin"><a href="#DataSourceTransactionManager-doBegin" class="headerlink" title="DataSourceTransactionManager#doBegin"></a>DataSourceTransactionManager#doBegin</h4><p>对应流程图49<br>开启事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">protected void doBegin(Object transaction, TransactionDefinition definition) &#123;</span><br><span class="line">	//强转为事务对象</span><br><span class="line">	DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">	Connection con = null;</span><br><span class="line">	try &#123;</span><br><span class="line">		//判断事务对象有无数据库链接保持器</span><br><span class="line">		if (!txObject.hasConnectionHolder() ||</span><br><span class="line">				txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">			//从数据源中获取一个数据库链接	</span><br><span class="line">			Connection newCon = obtainDataSource().getConnection();</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Acquired Connection [&quot; + newCon + &quot;] for JDBC transaction&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			//给事务对象设置数据库链接保持器</span><br><span class="line">			txObject.setConnectionHolder(new ConnectionHolder(newCon), true);</span><br><span class="line">		&#125;</span><br><span class="line">		//标记事务对象持有的数据库链接保持器是一个同步事务</span><br><span class="line">		txObject.getConnectionHolder().setSynchronizedWithTransaction(true);</span><br><span class="line">		//获取数据库链接</span><br><span class="line">		con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">		//获取事务隔离级别</span><br><span class="line">		Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">		//为事务对象设置事务隔离级别</span><br><span class="line">		txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line">		//设置只读方式 默认false</span><br><span class="line">		txObject.setReadOnly(definition.isReadOnly());</span><br><span class="line">		//如果是自动提交事务的话 改为手动提交</span><br><span class="line">		if (con.getAutoCommit()) &#123;</span><br><span class="line">			txObject.setMustRestoreAutoCommit(true);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Switching JDBC Connection [&quot; + con + &quot;] to manual commit&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			con.setAutoCommit(false);</span><br><span class="line">		&#125;</span><br><span class="line">		//设置数据库连接的事务为只读</span><br><span class="line">		prepareTransactionalConnection(con, definition);</span><br><span class="line">		//开启数据库连接的事务</span><br><span class="line">		txObject.getConnectionHolder().setTransactionActive(true);</span><br><span class="line">		// 设置超时时间</span><br><span class="line">		int timeout = determineTimeout(definition);</span><br><span class="line">		if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">			txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">		&#125;			</span><br><span class="line">		if (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">			//通过事务同步管理器把数据源作为key,数据库连接信息作为value保存到当前线程的ThreaLocal中				</span><br><span class="line">			TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		if (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">			//释放数据库链接资源</span><br><span class="line">			DataSourceUtils.releaseConnection(con, obtainDataSource());</span><br><span class="line">			txObject.setConnectionHolder(null, false);</span><br><span class="line">		&#125;</span><br><span class="line">		throw new CannotCreateTransactionException(&quot;Could not open JDBC Connection for transaction&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到TransactionAspectSupport#invokeWithinTransaction继续往下执行 对应流程图50<br>然后进入到</p>
<h4 id="TransactionInterceptor-invoke-1"><a href="#TransactionInterceptor-invoke-1" class="headerlink" title="TransactionInterceptor#invoke"></a>TransactionInterceptor#invoke</h4><p>对应流程图中的51  其实这个方法已经在上边分析过一部分对应流程图42 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">	// 获取被代理的类信息</span><br><span class="line">	Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);</span><br><span class="line"></span><br><span class="line">	// 执行事务  核心方法 对应流程图的43</span><br><span class="line">	return invokeWithinTransaction(invocation.getMethod(), targetClass, new CoroutinesInvocationCallback() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		@Nullable</span><br><span class="line">		public Object proceedWithInvocation() throws Throwable &#123;</span><br><span class="line">			//对应流程图52</span><br><span class="line">			return invocation.proceed();</span><br><span class="line">		&#125;</span><br><span class="line">		@Override</span><br><span class="line">		public Object getTarget() &#123;</span><br><span class="line">			return invocation.getThis();</span><br><span class="line">		&#125;</span><br><span class="line">		@Override</span><br><span class="line">		public Object[] getArguments() &#123;</span><br><span class="line">			return invocation.getArguments();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CglibMethodInvocation-proceed"><a href="#CglibMethodInvocation-proceed" class="headerlink" title="CglibMethodInvocation#proceed"></a>CglibMethodInvocation#proceed</h4><p>对应流程图52</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				//调用父类的执行方法 对应流程图53</span><br><span class="line">				return super.proceed();</span><br><span class="line">			&#125;</span><br><span class="line">			catch (RuntimeException ex) &#123;</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Exception ex) &#123;</span><br><span class="line">				if (ReflectionUtils.declaresException(getMethod(), ex.getClass()) ||</span><br><span class="line">						KotlinDetector.isKotlinType(getMethod().getDeclaringClass())) &#123;</span><br><span class="line">					// Propagate original exception if declared on the target method</span><br><span class="line">					// (with callers expecting it). Always propagate it for Kotlin code</span><br><span class="line">					// since checked exceptions do not have to be explicitly declared there.</span><br><span class="line">					throw ex;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					// Checked exception thrown in the interceptor but not declared on the</span><br><span class="line">					// target method signature -&gt; apply an UndeclaredThrowableException,</span><br><span class="line">					// aligned with standard JDK dynamic proxy behavior.</span><br><span class="line">					throw new UndeclaredThrowableException(ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReflectiveMethodInvocation-proceed-1"><a href="#ReflectiveMethodInvocation-proceed-1" class="headerlink" title="ReflectiveMethodInvocation#proceed"></a>ReflectiveMethodInvocation#proceed</h4><p>对应流程图53 这个方法在上边也分析过 对应流程图41</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">	// We start with an index of -1 and increment early.</span><br><span class="line">	if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">		//真正的执行方法 对应流程图54</span><br><span class="line">		return invokeJoinpoint();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object interceptorOrInterceptionAdvice =</span><br><span class="line">			this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line">	if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">		// Evaluate dynamic method matcher here: static part will already have</span><br><span class="line">		// been evaluated and found to match.</span><br><span class="line">		InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">				(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">		Class&lt;?&gt; targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());</span><br><span class="line">		if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) &#123;</span><br><span class="line">			return dm.interceptor.invoke(this);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// Dynamic matching failed.</span><br><span class="line">			// Skip this interceptor and invoke the next in the chain.</span><br><span class="line">			return proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span><br><span class="line">		// been evaluated statically before this object was constructed.</span><br><span class="line">		return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CglibAopProxy-CglibMethodInvocation-invokeJoinpoint"><a href="#CglibAopProxy-CglibMethodInvocation-invokeJoinpoint" class="headerlink" title="CglibAopProxy.CglibMethodInvocation#invokeJoinpoint"></a>CglibAopProxy.CglibMethodInvocation#invokeJoinpoint</h4><p>对应流程图54</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected Object invokeJoinpoint() throws Throwable &#123;</span><br><span class="line">	if (this.methodProxy != null) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			//执行代理方法的事务 对应流程图55</span><br><span class="line">			return this.methodProxy.invoke(this.target, this.arguments);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (CodeGenerationException ex) &#123;</span><br><span class="line">			logFastClassGenerationFailure(this.method);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return super.invokeJoinpoint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MethodProxy-invoke"><a href="#MethodProxy-invoke" class="headerlink" title="MethodProxy#invoke"></a>MethodProxy#invoke</h4><p>对应流程图55</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		init();</span><br><span class="line">		FastClassInfo fci = fastClassInfo;</span><br><span class="line">		//进入到真正的service方法执行业务逻辑 对应流程图56自己的业务方法就不展示了</span><br><span class="line">		return fci.f1.invoke(fci.i1, obj, args);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (InvocationTargetException ex) &#123;</span><br><span class="line">		throw ex.getTargetException();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IllegalArgumentException ex) &#123;</span><br><span class="line">		if (fastClassInfo.i1 &lt; 0)</span><br><span class="line">			throw new IllegalArgumentException(&quot;Protected method: &quot; + sig1);</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里事务执行流程算是走了一半了，剩余部分还有事务提交 或 事务异常回滚</p>
<h3 id="先说正常的事务提交"><a href="#先说正常的事务提交" class="headerlink" title="先说正常的事务提交"></a>先说正常的事务提交</h3><p>业务处理完后回到TransactionAspectSupport#invokeWithinTransaction继续往下执行</p>
<h4 id="TransactionAspectSupport-invokeWithinTransaction-1"><a href="#TransactionAspectSupport-invokeWithinTransaction-1" class="headerlink" title="TransactionAspectSupport#invokeWithinTransaction"></a>TransactionAspectSupport#invokeWithinTransaction</h4><p>对应流程图57 这个是事务执行核心方法 上边也分析过一部分 对应流程图中的43<br>执行事务  核心方法 接着往下执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,</span><br><span class="line">		final InvocationCallback invocation) throws Throwable &#123;</span><br><span class="line">	//获取事务属性源</span><br><span class="line">	TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">	//获取事务属性 对应流程图中的44</span><br><span class="line">	final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);</span><br><span class="line">	//获取事务管理器 一般是JdbcTransactionManager</span><br><span class="line">	final TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">	// JdbcTransactionManager 和 ReactiveTransactionManager 八竿子打不着 if分支不走，代码省略</span><br><span class="line">	if (this.reactiveAdapterRegistry != null &amp;&amp; tm instanceof ReactiveTransactionManager) &#123;</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">	// 获取配置的事务管理器</span><br><span class="line">	PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line">	// 获取被@Transactional注解标注的方法标识符</span><br><span class="line">	final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line">	// txAttr不为空  ptm是JdbcTransactionManager 和 CallbackPreferringPlatformTransactionManager 没有关系 进入if分支</span><br><span class="line">	if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">		// 如有必要通过给定的事务属性参数创建声明式的事务信息，对应流程图45</span><br><span class="line">		// 可以推出该if分支是处理声明式的事务 则另一个else分支就是处理编程式的事务啦</span><br><span class="line">		TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line">		try &#123;</span><br><span class="line">			//真正的业务方法回调</span><br><span class="line">			retVal = invocation.proceedWithInvocation();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			// target invocation exception</span><br><span class="line">			completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			cleanupTransactionInfo(txInfo);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (retVal != null &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">			// Set rollback-only in case of Vavr failure matching our rollback rules...</span><br><span class="line">			TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line">			if (status != null &amp;&amp; txAttr != null) &#123;</span><br><span class="line">				retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//业务方法处理完后，没有抛异常 进入这里 对应流程图58</span><br><span class="line">		commitTransactionAfterReturning(txInfo);</span><br><span class="line">		return retVal;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123;</span><br><span class="line">		Object result;</span><br><span class="line">		final ThrowableHolder throwableHolder = new ThrowableHolder();</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TransactionAspectSupport-commitTransactionAfterReturning"><a href="#TransactionAspectSupport-commitTransactionAfterReturning" class="headerlink" title="TransactionAspectSupport#commitTransactionAfterReturning"></a>TransactionAspectSupport#commitTransactionAfterReturning</h4><p>对应流程图58<br>处理完业务方法后提交事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) &#123;</span><br><span class="line">	if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		//执行提交操作 对应流程图59</span><br><span class="line">		txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractPlatformTransactionManager-commit"><a href="#AbstractPlatformTransactionManager-commit" class="headerlink" title="AbstractPlatformTransactionManager#commit"></a>AbstractPlatformTransactionManager#commit</h4><p>对应流程图59</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final void commit(TransactionStatus status) throws TransactionException &#123;</span><br><span class="line">	if (status.isCompleted()) &#123;</span><br><span class="line">		throw new IllegalTransactionStateException(</span><br><span class="line">				&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">	if (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">		if (defStatus.isDebug()) &#123;</span><br><span class="line">			logger.debug(&quot;Transactional code has requested rollback&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		processRollback(defStatus, false);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">		if (defStatus.isDebug()) &#123;</span><br><span class="line">			logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		processRollback(defStatus, true);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//处理事务提交  对应流程图60 </span><br><span class="line">	processCommit(defStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractPlatformTransactionManager-processCommit"><a href="#AbstractPlatformTransactionManager-processCommit" class="headerlink" title="AbstractPlatformTransactionManager#processCommit"></a>AbstractPlatformTransactionManager#processCommit</h4><p>对应流程图60</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">private void processCommit(DefaultTransactionStatus status) throws TransactionException &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		boolean beforeCompletionInvoked = false;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			boolean unexpectedRollback = false;</span><br><span class="line">			//提交之前的准备操作 是个空方法，为了后期扩展 对应流程图61</span><br><span class="line">			prepareForCommit(status);</span><br><span class="line">			//提交之前触发 对应流程图62 63 64 </span><br><span class="line">			//获取sqlSession进行提交，这里仅仅是做一些可能发生的OR映射保存到sqlsession，并不意味着事务在这里真正提交</span><br><span class="line">			triggerBeforeCommit(status);</span><br><span class="line">			//完成之前触发 对应流程图65 66 67 该方法做了两件事</span><br><span class="line">			//一个是通过事务同步管理器释放当前线程持有的资源 对应流程图68、69</span><br><span class="line">			//一个是关闭sqlSession 对应流程图67 最后一行代码</span><br><span class="line">			triggerBeforeCompletion(status);</span><br><span class="line">			beforeCompletionInvoked = true;</span><br><span class="line"></span><br><span class="line">			if (status.hasSavepoint()) &#123;</span><br><span class="line">				if (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(&quot;Releasing transaction savepoint&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">				status.releaseHeldSavepoint();</span><br><span class="line">			&#125;</span><br><span class="line">			else if (status.isNewTransaction()) &#123;</span><br><span class="line">				if (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(&quot;Initiating transaction commit&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">				//提交事务  对应流程图71、72、73</span><br><span class="line">				doCommit(status);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">				unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Throw UnexpectedRollbackException if we have a global rollback-only</span><br><span class="line">			// marker but still didn&#x27;t get a corresponding exception from commit.</span><br><span class="line">			if (unexpectedRollback) &#123;</span><br><span class="line">				throw new UnexpectedRollbackException(</span><br><span class="line">						&quot;Transaction silently rolled back because it has been marked as rollback-only&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (UnexpectedRollbackException ex) &#123;</span><br><span class="line">			// can only be caused by doCommit</span><br><span class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (TransactionException ex) &#123;</span><br><span class="line">			// can only be caused by doCommit</span><br><span class="line">			if (isRollbackOnCommitFailure()) &#123;</span><br><span class="line">				doRollbackOnCommitException(status, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">			&#125;</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException | Error ex) &#123;</span><br><span class="line">			if (!beforeCompletionInvoked) &#123;</span><br><span class="line">				triggerBeforeCompletion(status);</span><br><span class="line">			&#125;</span><br><span class="line">			doRollbackOnCommitException(status, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Trigger afterCommit callbacks, with an exception thrown there</span><br><span class="line">		// propagated to callers but the transaction still considered as committed.</span><br><span class="line">		try &#123;</span><br><span class="line">			triggerAfterCommit(status);</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		cleanupAfterCompletion(status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="再说异常的事务回滚"><a href="#再说异常的事务回滚" class="headerlink" title="再说异常的事务回滚"></a>再说异常的事务回滚</h3><p>业务处理异常后回到TransactionAspectSupport#invokeWithinTransaction的catch代码块</p>
<h4 id="TransactionAspectSupport-invokeWithinTransaction-2"><a href="#TransactionAspectSupport-invokeWithinTransaction-2" class="headerlink" title="TransactionAspectSupport#invokeWithinTransaction"></a>TransactionAspectSupport#invokeWithinTransaction</h4><p>对应流程图74 这个是事务执行核心方法 上边也分析过一部分 对应流程图中的43<br>执行事务 核心方法 进入catch代码块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,</span><br><span class="line">		final InvocationCallback invocation) throws Throwable &#123;</span><br><span class="line">	//获取事务属性源</span><br><span class="line">	TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">	//获取事务属性 对应流程图中的44</span><br><span class="line">	final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);</span><br><span class="line">	//获取事务管理器 一般是JdbcTransactionManager</span><br><span class="line">	final TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">	// JdbcTransactionManager 和 ReactiveTransactionManager 八竿子打不着 if分支不走，代码省略</span><br><span class="line">	if (this.reactiveAdapterRegistry != null &amp;&amp; tm instanceof ReactiveTransactionManager) &#123;</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">	// 获取配置的事务管理器</span><br><span class="line">	PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line">	// 获取被@Transactional注解标注的方法标识符</span><br><span class="line">	final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line">	// txAttr不为空  ptm是JdbcTransactionManager 和 CallbackPreferringPlatformTransactionManager 没有关系 进入if分支</span><br><span class="line">	if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">		// 如有必要通过给定的事务属性参数创建声明式的事务信息，对应流程图45</span><br><span class="line">		// 可以推出该if分支是处理声明式的事务 则另一个else分支就是处理编程式的事务啦</span><br><span class="line">		TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line">		try &#123;</span><br><span class="line">			//真正的业务方法回调</span><br><span class="line">			retVal = invocation.proceedWithInvocation();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			//业务代码抛异常执行回滚 对应流程图75</span><br><span class="line">			completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			cleanupTransactionInfo(txInfo);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (retVal != null &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">			// Set rollback-only in case of Vavr failure matching our rollback rules...</span><br><span class="line">			TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line">			if (status != null &amp;&amp; txAttr != null) &#123;</span><br><span class="line">				retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//业务方法处理完后，没有抛异常 进入这里 对应流程图58</span><br><span class="line">		commitTransactionAfterReturning(txInfo);</span><br><span class="line">		return retVal;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123;</span><br><span class="line">		Object result;</span><br><span class="line">		final ThrowableHolder throwableHolder = new ThrowableHolder();</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TransactionAspectSupport-completeTransactionAfterThrowing"><a href="#TransactionAspectSupport-completeTransactionAfterThrowing" class="headerlink" title="TransactionAspectSupport#completeTransactionAfterThrowing"></a>TransactionAspectSupport#completeTransactionAfterThrowing</h4><p>对应流程图75<br>业务抛出异常后需要进入catch 进行回滚操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) &#123;</span><br><span class="line">	if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() +</span><br><span class="line">					&quot;] after exception: &quot; + ex);</span><br><span class="line">		&#125;</span><br><span class="line">		// 调用rollbackOn方法判读是否需要回滚 对应流程图76、77检查业务抛出的异常是否满足回滚条件</span><br><span class="line">		// 回滚条件由@Transactional注解中声明的rollbackFor与noRollbackFor的共同作用</span><br><span class="line">		if (txInfo.transactionAttribute != null &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				// 调用回滚方法 对应流程图78</span><br><span class="line">				txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">			&#125;</span><br><span class="line">			catch (TransactionSystemException ex2) &#123;</span><br><span class="line">				logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);</span><br><span class="line">				ex2.initApplicationException(ex);</span><br><span class="line">				throw ex2;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (RuntimeException | Error ex2) &#123;</span><br><span class="line">				logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);</span><br><span class="line">				throw ex2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// We don&#x27;t roll back on this exception.</span><br><span class="line">			// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span><br><span class="line">			try &#123;</span><br><span class="line">				txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">			&#125;</span><br><span class="line">			catch (TransactionSystemException ex2) &#123;</span><br><span class="line">				logger.error(&quot;Application exception overridden by commit exception&quot;, ex);</span><br><span class="line">				ex2.initApplicationException(ex);</span><br><span class="line">				throw ex2;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (RuntimeException | Error ex2) &#123;</span><br><span class="line">				logger.error(&quot;Application exception overridden by commit exception&quot;, ex);</span><br><span class="line">				throw ex2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RuleBasedTransactionAttribute-rollbackOn"><a href="#RuleBasedTransactionAttribute-rollbackOn" class="headerlink" title="RuleBasedTransactionAttribute#rollbackOn"></a>RuleBasedTransactionAttribute#rollbackOn</h4><p>对应流程图76<br>判断业务抛出的异常是否满足回滚或不会滚的条件，也就是@Transactional注解中声明的rollbackFor与noRollbackFor的共同作用到底决定是否回滚</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public boolean rollbackOn(Throwable ex) &#123;</span><br><span class="line">	RollbackRuleAttribute winner = null;</span><br><span class="line">	int deepest = Integer.MAX_VALUE;</span><br><span class="line">	//rollBackRules包含了rollbackFor与noRollbackFor声明的异常	</span><br><span class="line">	if (this.rollbackRules != null) &#123;</span><br><span class="line">		for (RollbackRuleAttribute rule : this.rollbackRules) &#123;</span><br><span class="line">			//通过递归方法getDepth获取业务抛出的异常到rollbackFor与noRollbackFor声明异常的距离</span><br><span class="line">			// 需要说明的是77：调用递归方法判断抛出的异常是否匹配自己声明的rollbackfor的异常</span><br><span class="line">		    // 比如说事务注解中我们声明的回滚异常是NullPointerException,而业务也抛出了NPE异常 这里就直接匹配上了 返回0</span><br><span class="line">		    // 如果事务注解中我们声明的回滚异常是Exception,而业务抛出了NPE异常，没有直接匹配上，depth=0+1</span><br><span class="line">		    // 获取NPE的父类RuntimeException 再次调用递归方法，没有匹配上，depth=1+1</span><br><span class="line">		    // 获取RuntimeException的父类Exception,匹配上了 返回2</span><br><span class="line">			// 直接匹配返回0 有继承关系返回正数 返回-1就不匹配</span><br><span class="line">			int depth = rule.getDepth(ex);</span><br><span class="line">			// 注意第二个条件depth &lt; deepest才回进入分支给deepest赋值 说明deepest取值是最小的，也就是业务异常ex</span><br><span class="line">			// 到rollbackFor声明的异常之间的继承距离与业务异常到notRollbackFor声明的异常之间的继承距离两者中较小的</span><br><span class="line">			</span><br><span class="line">			// rollbackFor = Exception.class, noRollbackFor = RuntimeException.class业务抛出NPE异常 deepest = 1 winner是noRollbackFor</span><br><span class="line">			// rollbackFor = RuntimeException.class, noRollbackFor = Exception.class业务抛出NPE异常 deepest = 1 winner是rollbackFor 		</span><br><span class="line">			if (depth &gt;= 0 &amp;&amp; depth &lt; deepest) &#123;</span><br><span class="line">				deepest = depth;</span><br><span class="line">				winner = rule;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// User superclass behavior (rollback on unchecked) if no rule matches.</span><br><span class="line">	if (winner == null) &#123;</span><br><span class="line">		return super.rollbackOn(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	// 根据winner判断是否需要回滚 如果是noRollbackFor就不回滚，rollbackFor就回滚 注意前面的！！！</span><br><span class="line">	return !(winner instanceof NoRollbackRuleAttribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractPlatformTransactionManager-rollback"><a href="#AbstractPlatformTransactionManager-rollback" class="headerlink" title="AbstractPlatformTransactionManager#rollback"></a>AbstractPlatformTransactionManager#rollback</h4><p>对应流程图78<br>回滚方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final void rollback(TransactionStatus status) throws TransactionException &#123;</span><br><span class="line">	if (status.isCompleted()) &#123;</span><br><span class="line">		throw new IllegalTransactionStateException(</span><br><span class="line">				&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">	//处理回滚 对应流程图79</span><br><span class="line">	processRollback(defStatus, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractPlatformTransactionManager-processRollback"><a href="#AbstractPlatformTransactionManager-processRollback" class="headerlink" title="AbstractPlatformTransactionManager#processRollback"></a>AbstractPlatformTransactionManager#processRollback</h4><p>对应流程图79<br>处理回滚逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">private void processRollback(DefaultTransactionStatus status, boolean unexpected) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		boolean unexpectedRollback = unexpected;</span><br><span class="line">		try &#123;</span><br><span class="line">			//回滚之前做一些操作 对应流程图80、81、82、83</span><br><span class="line">			//81：调用释放资源的子方法82 83以及81方法最后一行关闭sqlsession</span><br><span class="line">			//82、83：通过事务同步管理器的doUnbindResource方法从缓存中删除当前线程绑定的资源</span><br><span class="line">			triggerBeforeCompletion(status);</span><br><span class="line"></span><br><span class="line">			if (status.hasSavepoint()) &#123;</span><br><span class="line">				if (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(&quot;Rolling back transaction to savepoint&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				status.rollbackToHeldSavepoint();</span><br><span class="line">			&#125;</span><br><span class="line">			else if (status.isNewTransaction()) &#123;</span><br><span class="line">				if (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(&quot;Initiating transaction rollback&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				//真正的回滚 对应流程图85</span><br><span class="line">				doRollback(status);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// Participating in larger transaction</span><br><span class="line">				if (status.hasTransaction()) &#123;</span><br><span class="line">					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">						if (status.isDebug()) &#123;</span><br><span class="line">							logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">						doSetRollbackOnly(status);</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						if (status.isDebug()) &#123;</span><br><span class="line">							logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				// Unexpected rollback only matters here if we&#x27;re asked to fail early</span><br><span class="line">				if (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">					unexpectedRollback = false;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException | Error ex) &#123;</span><br><span class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line">		// Raise UnexpectedRollbackException if we had a global rollback-only marker</span><br><span class="line">		if (unexpectedRollback) &#123;</span><br><span class="line">			throw new UnexpectedRollbackException(</span><br><span class="line">					&quot;Transaction rolled back because it has been marked as rollback-only&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		cleanupAfterCompletion(status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DataSourceTransactionManager-doRollback"><a href="#DataSourceTransactionManager-doRollback" class="headerlink" title="DataSourceTransactionManager#doRollback"></a>DataSourceTransactionManager#doRollback</h4><p>对应流程图85<br>真正的回滚操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void doRollback(DefaultTransactionStatus status) &#123;</span><br><span class="line">	DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">	Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">	if (status.isDebug()) &#123;</span><br><span class="line">		logger.debug(&quot;Rolling back JDBC transaction on Connection [&quot; + con + &quot;]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		//调用回滚方法 对应流程图86、87、88进行回滚</span><br><span class="line">		con.rollback();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (SQLException ex) &#123;</span><br><span class="line">		throw translateException(&quot;JDBC rollback&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到AbstractPlatformTransactionManager#processRollback方法继续往下执行</p>
<h4 id="AbstractPlatformTransactionManager-processRollback-1"><a href="#AbstractPlatformTransactionManager-processRollback-1" class="headerlink" title="AbstractPlatformTransactionManager#processRollback"></a>AbstractPlatformTransactionManager#processRollback</h4><p>对应流程图89<br>做一些回滚之后的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private void processRollback(DefaultTransactionStatus status, boolean unexpected) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		boolean unexpectedRollback = unexpected;</span><br><span class="line">		try &#123;</span><br><span class="line">			//回滚之前做一些操作 对应流程图80、81、82、83</span><br><span class="line">			//81：调用释放资源的子方法82 83以及81方法最后一行关闭sqlsession</span><br><span class="line">			//82、83：通过事务同步管理器的doUnbindResource方法从缓存中删除当前线程绑定的资源</span><br><span class="line">			triggerBeforeCompletion(status);</span><br><span class="line"></span><br><span class="line">			if (status.hasSavepoint()) &#123;</span><br><span class="line">				if (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(&quot;Rolling back transaction to savepoint&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				status.rollbackToHeldSavepoint();</span><br><span class="line">			&#125;</span><br><span class="line">			else if (status.isNewTransaction()) &#123;</span><br><span class="line">				if (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(&quot;Initiating transaction rollback&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				//真正的回滚 对应流程图85</span><br><span class="line">				doRollback(status);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// Participating in larger transaction</span><br><span class="line">				if (status.hasTransaction()) &#123;</span><br><span class="line">					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">						if (status.isDebug()) &#123;</span><br><span class="line">							logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">						doSetRollbackOnly(status);</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						if (status.isDebug()) &#123;</span><br><span class="line">							logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				// Unexpected rollback only matters here if we&#x27;re asked to fail early</span><br><span class="line">				if (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">					unexpectedRollback = false;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException | Error ex) &#123;</span><br><span class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		// 做一些回滚之后的操作 重置事务资源 对应流程图90、91、92、93 </span><br><span class="line">		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line">		// Raise UnexpectedRollbackException if we had a global rollback-only marker</span><br><span class="line">		if (unexpectedRollback) &#123;</span><br><span class="line">			throw new UnexpectedRollbackException(</span><br><span class="line">					&quot;Transaction rolled back because it has been marked as rollback-only&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		//做一些回滚后的资源清理工作 对应流程图94、95、96</span><br><span class="line">		cleanupAfterCompletion(status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransactionAspectSupport#invokeWithinTransaction的catch代码块的事务回滚完成后，继续往下走进入finally代码块做最终的清理</p>
<h4 id="TransactionAspectSupport-invokeWithinTransaction-3"><a href="#TransactionAspectSupport-invokeWithinTransaction-3" class="headerlink" title="TransactionAspectSupport#invokeWithinTransaction"></a>TransactionAspectSupport#invokeWithinTransaction</h4><p>对应流程图97 这个是事务执行核心方法 上边也分析过一部分 对应流程图中的43、74<br>执行事务 核心方法 进入finally代码块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,</span><br><span class="line">		final InvocationCallback invocation) throws Throwable &#123;</span><br><span class="line">	//获取事务属性源</span><br><span class="line">	TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">	//获取事务属性 对应流程图中的44</span><br><span class="line">	final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);</span><br><span class="line">	//获取事务管理器 一般是JdbcTransactionManager</span><br><span class="line">	final TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">	// JdbcTransactionManager 和 ReactiveTransactionManager 八竿子打不着 if分支不走，代码省略</span><br><span class="line">	if (this.reactiveAdapterRegistry != null &amp;&amp; tm instanceof ReactiveTransactionManager) &#123;</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">	// 获取配置的事务管理器</span><br><span class="line">	PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line">	// 获取被@Transactional注解标注的方法标识符</span><br><span class="line">	final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line">	// txAttr不为空  ptm是JdbcTransactionManager 和 CallbackPreferringPlatformTransactionManager 没有关系 进入if分支</span><br><span class="line">	if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">		// 如有必要通过给定的事务属性参数创建声明式的事务信息，对应流程图45</span><br><span class="line">		// 可以推出该if分支是处理声明式的事务 则另一个else分支就是处理编程式的事务啦</span><br><span class="line">		TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line">		try &#123;</span><br><span class="line">			//真正的业务方法回调</span><br><span class="line">			retVal = invocation.proceedWithInvocation();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			//业务代码抛异常执行回滚 对应流程图75</span><br><span class="line">			completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			// 回滚操作完成后回到这里进行最后的清理工作 对应流程图97、98、99</span><br><span class="line">			cleanupTransactionInfo(txInfo);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (retVal != null &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">			// Set rollback-only in case of Vavr failure matching our rollback rules...</span><br><span class="line">			TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line">			if (status != null &amp;&amp; txAttr != null) &#123;</span><br><span class="line">				retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//业务方法处理完后，没有抛异常 进入这里 对应流程图58</span><br><span class="line">		commitTransactionAfterReturning(txInfo);</span><br><span class="line">		return retVal;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123;</span><br><span class="line">		Object result;</span><br><span class="line">		final ThrowableHolder throwableHolder = new ThrowableHolder();</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单总结：事务执行：从缓存attributeCache中获取事务属性信息，创建事务，设置事务属性，开启事务，执行代理方法的业务逻辑，成功就结束，失败的话就回滚事务，回滚事务会根据异常类型判断是否支持回滚，一般是RuntimeException都支持回滚。</p>
<h2 id="事务失效的场景"><a href="#事务失效的场景" class="headerlink" title="事务失效的场景"></a>事务失效的场景</h2><p>1、方法访问权限不是public AbstractFallbackTransactionAttributeSource#computeTransactionAttribute 代码中有校验<br>2、方法被final修饰，spring事务底层使用了aop，也就是通过jdk或者cglib代理，生成了代理对象，从而实现的事务功能但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，从而事务失效<br>3、方法内部调用本类的事务方法，直接调用本类中的方法是不走代理的<br>4、没有被spring管理，比如说少了注册为bean的注解@Service @Component等<br>5、多线程调用 上边有说过一个线程一个数据库链接，同一个事务也就是同一个数据库链接才能提交或回滚，如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。<br>6、数据库引擎不支持事务，比如mysql的myisam<br>7、没有配置事务或者开启事务 一般是老项目xml配置的没有配事务管理，现在springboot通过DataSourceTransactionManagerAutoConfiguration类，已经默默的帮你开启了事务<br>8、事务传播行为设置有问题  比如 @Transactional(propagation &#x3D; Propagation.NEVER) 本身就不支持事务<br>9、try-catch捕获了异常没有显式的抛出<br>10、抛出的异常类型和自己声明的不匹配，比如说@Transactional(rollbackFor &#x3D; NullPointerException.class),业务却抛出了OutOfMemeryException<br>11、如果没有声明回滚异常类型，默认式RuntimeException及其子类，而我们在catch中抛出了Exception</p>
<h2 id="看完以后"><a href="#看完以后" class="headerlink" title="看完以后"></a>看完以后</h2><p>点赞，点赞是免费的，但却能激励我保持创作，还能帮助更多的人看到这篇文章。</p>
<p>留言，有任何问题，都可以在评论区留言，我会尽可能回复。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xuchao6969.github.io">xuchao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xuchao6969.github.io/2022/10/04/SpringTransactionManager/">https://xuchao6969.github.io/2022/10/04/SpringTransactionManager/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xuchao6969.github.io" target="_blank">xuchaoのblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring/">spring</a></div><div class="post_share"><div class="social-share" data-image="/img/wuxin1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/02/SpringBeanLifecycle/"><img class="prev-cover" src="/img/zyz1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring bean的生命周期</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/20/HexoCommandIntroduce/"><img class="next-cover" src="/img/xiaose2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hexo 常用命令说明</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/02/SpringBeanLifecycle/" title="Spring bean的生命周期"><img class="cover" src="/img/zyz1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-02</div><div class="title">Spring bean的生命周期</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/leiwujie1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xuchao</div><div class="author-info__description">记录一下工作学习生活上的分享~~~ </div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xuchao6969"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xuchao6969" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xucha_o@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-transaction-manager"><span class="toc-number">1.</span> <span class="toc-text">Spring transaction manager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFtransaction"><span class="toc-number">2.</span> <span class="toc-text">什么是transaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7ACID"><span class="toc-number">3.</span> <span class="toc-text">事务的四个特性ACID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">4.</span> <span class="toc-text">事务传播行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">事务执行的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">6.</span> <span class="toc-text">事务的使用例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">调用流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AF5-3-23"><span class="toc-number">8.</span> <span class="toc-text">spring的版本是5.3.23</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringApplication-run-SpringTransactionApplication-class-args"><span class="toc-number">9.1.</span> <span class="toc-text">SpringApplication.run(SpringTransactionApplication.class, args);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractApplicationContext-refresh"><span class="toc-number">9.2.</span> <span class="toc-text">AbstractApplicationContext#refresh</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractAutoProxyCreator-wrapIfNecessary"><span class="toc-number">9.3.</span> <span class="toc-text">AbstractAutoProxyCreator#wrapIfNecessary</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractAdvisorAutoProxyCreator-getAdvicesAndAdvisorsForBean"><span class="toc-number">9.3.1.</span> <span class="toc-text">AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractAdvisorAutoProxyCreator-findEligibleAdvisors"><span class="toc-number">9.3.2.</span> <span class="toc-text">AbstractAdvisorAutoProxyCreator#findEligibleAdvisors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AnnotationAwareAspectJAutoProxyCreator-findCandidateAdvisors"><span class="toc-number">9.3.3.</span> <span class="toc-text">AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractAdvisorAutoProxyCreator-findCandidateAdvisors"><span class="toc-number">9.3.4.</span> <span class="toc-text">AbstractAdvisorAutoProxyCreator#findCandidateAdvisors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactoryAdvisorRetrievalHelper-findAdvisorBeans"><span class="toc-number">9.3.5.</span> <span class="toc-text">BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractAdvisorAutoProxyCreator-findAdvisorsThatCanApply"><span class="toc-number">9.3.6.</span> <span class="toc-text">AbstractAdvisorAutoProxyCreator#findAdvisorsThatCanApply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AopUtils-findAdvisorsThatCanApply"><span class="toc-number">9.3.7.</span> <span class="toc-text">AopUtils#findAdvisorsThatCanApply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AopUtils-canApply-Advisor-advisor-Class-lt-gt-targetClass-boolean-hasIntroductions"><span class="toc-number">9.3.8.</span> <span class="toc-text">AopUtils#canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AopUtils-canApply-Pointcut-pc-Class-lt-gt-targetClass-boolean-hasIntroductions"><span class="toc-number">9.3.9.</span> <span class="toc-text">AopUtils#canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionAttributeSourcePointcut-matches"><span class="toc-number">9.3.10.</span> <span class="toc-text">TransactionAttributeSourcePointcut#matches</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractFallbackTransactionAttributeSource-getTransactionAttribute"><span class="toc-number">9.3.11.</span> <span class="toc-text">AbstractFallbackTransactionAttributeSource#getTransactionAttribute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractFallbackTransactionAttributeSource-computeTransactionAttribute"><span class="toc-number">9.3.12.</span> <span class="toc-text">AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AnnotationTransactionAttributeSource-findTransactionAttribute"><span class="toc-number">9.3.13.</span> <span class="toc-text">AnnotationTransactionAttributeSource#findTransactionAttribute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AnnotationTransactionAttributeSource-determineTransactionAttribute"><span class="toc-number">9.3.14.</span> <span class="toc-text">AnnotationTransactionAttributeSource#determineTransactionAttribute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringTransactionAnnotationParser-parseTransactionAnnotation"><span class="toc-number">9.3.15.</span> <span class="toc-text">SpringTransactionAnnotationParser#parseTransactionAnnotation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringTransactionAnnotationParser-parseTransactionAnnotation-AnnotationAttributes-attributes"><span class="toc-number">9.3.16.</span> <span class="toc-text">SpringTransactionAnnotationParser#parseTransactionAnnotation(AnnotationAttributes attributes)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractFallbackTransactionAttributeSource-getTransactionAttribute-1"><span class="toc-number">9.3.17.</span> <span class="toc-text">AbstractFallbackTransactionAttributeSource#getTransactionAttribute</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAaop%E4%BB%A3%E7%90%86"><span class="toc-number">9.4.</span> <span class="toc-text">创建aop代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.5.</span> <span class="toc-text">下面是事务执行过程介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CglibAopProxy-DynamicAdvisedInterceptor-intercept"><span class="toc-number">9.5.1.</span> <span class="toc-text">CglibAopProxy.DynamicAdvisedInterceptor#intercept</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CglibAopProxy-CglibMethodInvocation"><span class="toc-number">9.5.2.</span> <span class="toc-text">CglibAopProxy.CglibMethodInvocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReflectiveMethodInvocation-proceed"><span class="toc-number">9.5.3.</span> <span class="toc-text">ReflectiveMethodInvocation#proceed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionInterceptor-invoke"><span class="toc-number">9.5.4.</span> <span class="toc-text">TransactionInterceptor#invoke</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionAspectSupport-invokeWithinTransaction"><span class="toc-number">9.5.5.</span> <span class="toc-text">TransactionAspectSupport#invokeWithinTransaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractFallbackTransactionAttributeSource-getTransactionAttribute-2"><span class="toc-number">9.5.6.</span> <span class="toc-text">AbstractFallbackTransactionAttributeSource#getTransactionAttribute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionAspectSupport-createTransactionIfNecessary"><span class="toc-number">9.5.7.</span> <span class="toc-text">TransactionAspectSupport#createTransactionIfNecessary</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractPlatformTransactionManager-getTransaction"><span class="toc-number">9.5.8.</span> <span class="toc-text">AbstractPlatformTransactionManager#getTransaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataSourceTransactionManager-doGetTransaction"><span class="toc-number">9.5.9.</span> <span class="toc-text">DataSourceTransactionManager#doGetTransaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractPlatformTransactionManager-startTransaction"><span class="toc-number">9.5.10.</span> <span class="toc-text">AbstractPlatformTransactionManager#startTransaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataSourceTransactionManager-doBegin"><span class="toc-number">9.5.11.</span> <span class="toc-text">DataSourceTransactionManager#doBegin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionInterceptor-invoke-1"><span class="toc-number">9.5.12.</span> <span class="toc-text">TransactionInterceptor#invoke</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CglibMethodInvocation-proceed"><span class="toc-number">9.5.13.</span> <span class="toc-text">CglibMethodInvocation#proceed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReflectiveMethodInvocation-proceed-1"><span class="toc-number">9.5.14.</span> <span class="toc-text">ReflectiveMethodInvocation#proceed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CglibAopProxy-CglibMethodInvocation-invokeJoinpoint"><span class="toc-number">9.5.15.</span> <span class="toc-text">CglibAopProxy.CglibMethodInvocation#invokeJoinpoint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MethodProxy-invoke"><span class="toc-number">9.5.16.</span> <span class="toc-text">MethodProxy#invoke</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%AF%B4%E6%AD%A3%E5%B8%B8%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4"><span class="toc-number">9.6.</span> <span class="toc-text">先说正常的事务提交</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionAspectSupport-invokeWithinTransaction-1"><span class="toc-number">9.6.1.</span> <span class="toc-text">TransactionAspectSupport#invokeWithinTransaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionAspectSupport-commitTransactionAfterReturning"><span class="toc-number">9.6.2.</span> <span class="toc-text">TransactionAspectSupport#commitTransactionAfterReturning</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractPlatformTransactionManager-commit"><span class="toc-number">9.6.3.</span> <span class="toc-text">AbstractPlatformTransactionManager#commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractPlatformTransactionManager-processCommit"><span class="toc-number">9.6.4.</span> <span class="toc-text">AbstractPlatformTransactionManager#processCommit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%AF%B4%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A"><span class="toc-number">9.7.</span> <span class="toc-text">再说异常的事务回滚</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionAspectSupport-invokeWithinTransaction-2"><span class="toc-number">9.7.1.</span> <span class="toc-text">TransactionAspectSupport#invokeWithinTransaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionAspectSupport-completeTransactionAfterThrowing"><span class="toc-number">9.7.2.</span> <span class="toc-text">TransactionAspectSupport#completeTransactionAfterThrowing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RuleBasedTransactionAttribute-rollbackOn"><span class="toc-number">9.7.3.</span> <span class="toc-text">RuleBasedTransactionAttribute#rollbackOn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractPlatformTransactionManager-rollback"><span class="toc-number">9.7.4.</span> <span class="toc-text">AbstractPlatformTransactionManager#rollback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractPlatformTransactionManager-processRollback"><span class="toc-number">9.7.5.</span> <span class="toc-text">AbstractPlatformTransactionManager#processRollback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataSourceTransactionManager-doRollback"><span class="toc-number">9.7.6.</span> <span class="toc-text">DataSourceTransactionManager#doRollback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractPlatformTransactionManager-processRollback-1"><span class="toc-number">9.7.7.</span> <span class="toc-text">AbstractPlatformTransactionManager#processRollback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TransactionAspectSupport-invokeWithinTransaction-3"><span class="toc-number">9.7.8.</span> <span class="toc-text">TransactionAspectSupport#invokeWithinTransaction</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">10.</span> <span class="toc-text">事务失效的场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E5%AE%8C%E4%BB%A5%E5%90%8E"><span class="toc-number">11.</span> <span class="toc-text">看完以后</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/16/NucleicAcidDetection/" title="核酸检测混检为什么采用1管10个样本进行检查"><img src="/img/lihanyi.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="核酸检测混检为什么采用1管10个样本进行检查"/></a><div class="content"><a class="title" href="/2023/03/16/NucleicAcidDetection/" title="核酸检测混检为什么采用1管10个样本进行检查">核酸检测混检为什么采用1管10个样本进行检查</a><time datetime="2023-03-16T10:20:51.000Z" title="发表于 2023-03-16 18:20:51">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/HexoBlogBackup/" title="Hexo 博客备份"><img src="/img/leiwujie1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo 博客备份"/></a><div class="content"><a class="title" href="/2022/11/21/HexoBlogBackup/" title="Hexo 博客备份">Hexo 博客备份</a><time datetime="2022-11-21T09:09:25.000Z" title="发表于 2022-11-21 17:09:25">2022-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/HexoConfigGiscus/" title="Hexo+Butterfly配置Giscus评论"><img src="/img/leiwujie.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo+Butterfly配置Giscus评论"/></a><div class="content"><a class="title" href="/2022/11/21/HexoConfigGiscus/" title="Hexo+Butterfly配置Giscus评论">Hexo+Butterfly配置Giscus评论</a><time datetime="2022-11-21T09:09:25.000Z" title="发表于 2022-11-21 17:09:25">2022-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/20/HexoCommandIntroduce/" title="Hexo 常用命令说明"><img src="/img/xiaose2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo 常用命令说明"/></a><div class="content"><a class="title" href="/2022/11/20/HexoCommandIntroduce/" title="Hexo 常用命令说明">Hexo 常用命令说明</a><time datetime="2022-11-20T09:09:25.000Z" title="发表于 2022-11-20 17:09:25">2022-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/04/SpringTransactionManager/" title="Spring transaction manager"><img src="/img/wuxin1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring transaction manager"/></a><div class="content"><a class="title" href="/2022/10/04/SpringTransactionManager/" title="Spring transaction manager">Spring transaction manager</a><time datetime="2022-10-04T10:20:51.000Z" title="发表于 2022-10-04 18:20:51">2022-10-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/wuxin1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> xuchao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadGiscus () {
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'xuchao6969/blog_giscus',
    'data-repo-id': 'R_kgDOIMjKeA',
    'data-category-id': 'DIC_kwDOIMjKeM4CR7sR',
    'data-mapping': 'pathname',
    'data-theme': nowTheme,
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme () {
  const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }

  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}

if ('Giscus' === 'Giscus' || !false) {
  if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>